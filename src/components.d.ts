/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BadgeColor, BadgeShape } from "./components/badge/badge-interface";
import { WcsButtonMode, WcsButtonShape, WcsButtonType } from "./components/button/button-interface";
import { CardMode } from "./components/card/card-interface";
import { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
import { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
import { WcsDropdownPlacement } from "./components/dropdown/dropdown-interface";
import { EditableComponentUpdateEvent, EditableFieldType, FormatFn, ValidateFn } from "./components/editable-field/editable-field-interface";
import { WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridRowSelectedEventDetails, WcsGridSelectionConfig, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
import { HorizontalStepClickEvent, HorizontalStepConfig, HorizontalStepperMode } from "./components/horizontal-stepper/horizontal-stepper-interface";
import { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes } from "./components/input/input-interface";
import { MaterialIconFamily, MaterialIconSize } from "./components/mat-icon/mat-icon-interface";
import { ModalSize } from "./components/modal/modal-interface";
import { RadioGroupChangeEventDetail, RadioGroupMode } from "./components/radio-group/radio-group-interface";
import { RadioChosedEvent } from "./components/radio/radio-interface";
import { SelectChangeEventDetail } from "./components/select/select-interface";
import { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
import { WcsSpinnerMode } from "./components/spinner/spinner-interface";
import { SwitchChangeEventDetail, SwitchLabelAlignment } from "./components/switch/switch-interface";
import { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
import { TextareaChangeEventDetail } from "./components/textarea/textarea-interface";
import { WcsTooltipAppendTo, WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export namespace Components {
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight": boolean;
    }
    interface WcsAccordionContent {
    }
    interface WcsAccordionHeader {
    }
    interface WcsAccordionPanel {
        "close": () => Promise<void>;
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight": boolean;
        "open": boolean;
    }
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter": boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color": BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape": BadgeShape;
    }
    interface WcsButton {
        /**
          * Specify wether the button is disabled or not.
         */
        "disabled": boolean;
        /**
          * Set a URL to point to. If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading": boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode": WcsButtonMode;
        /**
          * Specify wether the button should have a ripple effect or not.
         */
        "ripple": boolean;
        /**
          * Specify the shape of the button.
         */
        "shape": WcsButtonShape;
        /**
          * Specify the button type.
         */
        "type": WcsButtonType;
    }
    interface WcsCard {
        "mode": CardMode;
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled": boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment": CheckboxLabelAlignment;
        "name": string;
    }
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName": string;
    }
    interface WcsComNavCategory {
        /**
          * Close the category
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the category
         */
        "open": () => Promise<void>;
    }
    interface WcsComNavSubmenu {
        /**
          * Close the menu
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the menu
         */
        "open": () => Promise<void>;
        "panelDescription": string;
        "panelTitle": string;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled": boolean;
        /**
          * Dropdown's button mode
         */
        "mode": WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow": boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement": WcsDropdownPlacement;
        /**
          * Dropdown's button shape
         */
        "shape": WcsButtonShape;
    }
    interface WcsDropdownDivider {
    }
    interface WcsDropdownHeader {
    }
    interface WcsDropdownItem {
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg": string;
        /**
          * Function used to format the value
         */
        "formatFn": FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * Specify whether the field is editable or not
         */
        "readonly": boolean;
        /**
          * Specifies which component is used for editing
         */
        "type": EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn": ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value": any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError": boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text": string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text": string;
    }
    interface WcsGrid {
        "data": any[];
        /**
          * Flag to display spinner during data loading
         */
        "loading": boolean;
        /**
          * Name of the object's key that will be used to display the cells whose keyValue attribute matches to the object's value for this key.
         */
        "rowIdPath": string;
        /**
          * Set the selected items
         */
        "selectedItems": any | any[];
        /**
          * Used to manage grid's row selection
         */
        "selectionConfig": WcsGridSelectionConfig;
        /**
          * True to manage sort and pagination with a backend server, default: false
         */
        "serverMode": boolean;
        "wcsGridPaginationId": string;
    }
    interface WcsGridColumn {
        "customCells": boolean;
        "formatter": WcsCellFormatter;
        "hidden": boolean;
        "name": string;
        "path": string;
        "sort": boolean;
        "sortFn": WcsSortFn;
        "sortOrder": WcsSortOrder;
        /**
          * Set the column <th> element width
         */
        "width": string;
    }
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId": string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId": any;
    }
    interface WcsGridPagination {
        "availablePageSizes": number[];
        "currentPage": number;
        "itemsCount": number;
        "pageCount": number;
        "pageSize": number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        "small": boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete": boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep": number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode": HorizontalStepperMode;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        /**
          * steps to display
         */
        "steps": HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon": string;
        "size": 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Sets blur on the native `input` in `wcs-input`. Use this method instead of the global `input.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `input` in `wcs-input`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel": string;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required": boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated": boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family": MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon": string;
        /**
          * Size of the icon
         */
        "size": MaterialIconSize;
    }
    interface WcsModal {
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions": boolean;
        /**
          * Displays the modal
         */
        "show": boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton": boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size": ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop": boolean;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href": string;
        /**
          * This attribute specify the text of the item.
         */
        "text": string;
    }
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel": boolean;
        /**
          * Whether the component display the small version
         */
        "small": boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value": number;
    }
    interface WcsProgressRadial {
        "showLabel": boolean;
        "size": number;
        "value": number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked": boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled": boolean;
        "label": string;
        "mode": RadioGroupMode;
        "value": any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode": RadioGroupMode;
        "name": any;
        "value": any | any[] | undefined | null;
    }
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips": boolean;
        /**
          * Close the component.
         */
        "close": () => Promise<void>;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled": boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Open the component.
         */
        "open": () => Promise<void>;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled": boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple": boolean;
        /**
          * Wether this option is selected.
         */
        "selected": boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode": WcsSpinnerMode;
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled": boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment": SwitchLabelAlignment;
        "name": string;
    }
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header": string;
        "itemKey": any;
    }
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align": WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter": boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly": boolean;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex": number;
        "selectedKey": any;
    }
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow": boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize": string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit": boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * This method make the textarea automatically adopt the size of the content without a scroll bar
         */
        "fitContent": () => Promise<void>;
        /**
          * Returns the native `<textarea>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * Sets blur on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo": WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content": string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay": number | [number, number];
        /**
          * Temporarily prevent the tooltip from showing or hiding
         */
        "disable": () => Promise<void>;
        /**
          * Duration in ms of the transition animation.
         */
        "duration": number | [number, number];
        /**
          * Re-enable a disabled tooltip
         */
        "enable": () => Promise<void>;
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for": string;
        /**
          * Programmatically hide the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive": boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.
         */
        "maxWidth": string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position": WcsTooltipPosition;
        /**
          * Programmatically show the tooltip
         */
        "show": () => Promise<void>;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme": string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger": string;
    }
}
export interface WcsAccordionPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsAccordionPanelElement;
}
export interface WcsCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsCheckboxElement;
}
export interface WcsComNavCategoryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavCategoryElement;
}
export interface WcsComNavSubmenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavSubmenuElement;
}
export interface WcsDropdownItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsDropdownItemElement;
}
export interface WcsEditableFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsEditableFieldElement;
}
export interface WcsGridCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridElement;
}
export interface WcsGridColumnCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridColumnElement;
}
export interface WcsGridPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridPaginationElement;
}
export interface WcsHorizontalStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsHorizontalStepperElement;
}
export interface WcsInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsInputElement;
}
export interface WcsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsModalElement;
}
export interface WcsRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioElement;
}
export interface WcsRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioGroupElement;
}
export interface WcsSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectElement;
}
export interface WcsSelectOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectOptionElement;
}
export interface WcsSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSwitchElement;
}
export interface WcsTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabElement;
}
export interface WcsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabsElement;
}
export interface WcsTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTextareaElement;
}
declare global {
    interface HTMLWcsAccordionElement extends Components.WcsAccordion, HTMLStencilElement {
    }
    var HTMLWcsAccordionElement: {
        prototype: HTMLWcsAccordionElement;
        new (): HTMLWcsAccordionElement;
    };
    interface HTMLWcsAccordionContentElement extends Components.WcsAccordionContent, HTMLStencilElement {
    }
    var HTMLWcsAccordionContentElement: {
        prototype: HTMLWcsAccordionContentElement;
        new (): HTMLWcsAccordionContentElement;
    };
    interface HTMLWcsAccordionHeaderElement extends Components.WcsAccordionHeader, HTMLStencilElement {
    }
    var HTMLWcsAccordionHeaderElement: {
        prototype: HTMLWcsAccordionHeaderElement;
        new (): HTMLWcsAccordionHeaderElement;
    };
    interface HTMLWcsAccordionPanelElement extends Components.WcsAccordionPanel, HTMLStencilElement {
    }
    var HTMLWcsAccordionPanelElement: {
        prototype: HTMLWcsAccordionPanelElement;
        new (): HTMLWcsAccordionPanelElement;
    };
    interface HTMLWcsActionBarElement extends Components.WcsActionBar, HTMLStencilElement {
    }
    var HTMLWcsActionBarElement: {
        prototype: HTMLWcsActionBarElement;
        new (): HTMLWcsActionBarElement;
    };
    interface HTMLWcsAppElement extends Components.WcsApp, HTMLStencilElement {
    }
    var HTMLWcsAppElement: {
        prototype: HTMLWcsAppElement;
        new (): HTMLWcsAppElement;
    };
    interface HTMLWcsBadgeElement extends Components.WcsBadge, HTMLStencilElement {
    }
    var HTMLWcsBadgeElement: {
        prototype: HTMLWcsBadgeElement;
        new (): HTMLWcsBadgeElement;
    };
    interface HTMLWcsButtonElement extends Components.WcsButton, HTMLStencilElement {
    }
    var HTMLWcsButtonElement: {
        prototype: HTMLWcsButtonElement;
        new (): HTMLWcsButtonElement;
    };
    interface HTMLWcsCardElement extends Components.WcsCard, HTMLStencilElement {
    }
    var HTMLWcsCardElement: {
        prototype: HTMLWcsCardElement;
        new (): HTMLWcsCardElement;
    };
    interface HTMLWcsCardBodyElement extends Components.WcsCardBody, HTMLStencilElement {
    }
    var HTMLWcsCardBodyElement: {
        prototype: HTMLWcsCardBodyElement;
        new (): HTMLWcsCardBodyElement;
    };
    interface HTMLWcsCheckboxElement extends Components.WcsCheckbox, HTMLStencilElement {
    }
    var HTMLWcsCheckboxElement: {
        prototype: HTMLWcsCheckboxElement;
        new (): HTMLWcsCheckboxElement;
    };
    interface HTMLWcsComNavElement extends Components.WcsComNav, HTMLStencilElement {
    }
    var HTMLWcsComNavElement: {
        prototype: HTMLWcsComNavElement;
        new (): HTMLWcsComNavElement;
    };
    interface HTMLWcsComNavCategoryElement extends Components.WcsComNavCategory, HTMLStencilElement {
    }
    var HTMLWcsComNavCategoryElement: {
        prototype: HTMLWcsComNavCategoryElement;
        new (): HTMLWcsComNavCategoryElement;
    };
    interface HTMLWcsComNavSubmenuElement extends Components.WcsComNavSubmenu, HTMLStencilElement {
    }
    var HTMLWcsComNavSubmenuElement: {
        prototype: HTMLWcsComNavSubmenuElement;
        new (): HTMLWcsComNavSubmenuElement;
    };
    interface HTMLWcsDividerElement extends Components.WcsDivider, HTMLStencilElement {
    }
    var HTMLWcsDividerElement: {
        prototype: HTMLWcsDividerElement;
        new (): HTMLWcsDividerElement;
    };
    interface HTMLWcsDropdownElement extends Components.WcsDropdown, HTMLStencilElement {
    }
    var HTMLWcsDropdownElement: {
        prototype: HTMLWcsDropdownElement;
        new (): HTMLWcsDropdownElement;
    };
    interface HTMLWcsDropdownDividerElement extends Components.WcsDropdownDivider, HTMLStencilElement {
    }
    var HTMLWcsDropdownDividerElement: {
        prototype: HTMLWcsDropdownDividerElement;
        new (): HTMLWcsDropdownDividerElement;
    };
    interface HTMLWcsDropdownHeaderElement extends Components.WcsDropdownHeader, HTMLStencilElement {
    }
    var HTMLWcsDropdownHeaderElement: {
        prototype: HTMLWcsDropdownHeaderElement;
        new (): HTMLWcsDropdownHeaderElement;
    };
    interface HTMLWcsDropdownItemElement extends Components.WcsDropdownItem, HTMLStencilElement {
    }
    var HTMLWcsDropdownItemElement: {
        prototype: HTMLWcsDropdownItemElement;
        new (): HTMLWcsDropdownItemElement;
    };
    interface HTMLWcsEditableFieldElement extends Components.WcsEditableField, HTMLStencilElement {
    }
    var HTMLWcsEditableFieldElement: {
        prototype: HTMLWcsEditableFieldElement;
        new (): HTMLWcsEditableFieldElement;
    };
    interface HTMLWcsErrorElement extends Components.WcsError, HTMLStencilElement {
    }
    var HTMLWcsErrorElement: {
        prototype: HTMLWcsErrorElement;
        new (): HTMLWcsErrorElement;
    };
    interface HTMLWcsFieldElement extends Components.WcsField, HTMLStencilElement {
    }
    var HTMLWcsFieldElement: {
        prototype: HTMLWcsFieldElement;
        new (): HTMLWcsFieldElement;
    };
    interface HTMLWcsFieldContentElement extends Components.WcsFieldContent, HTMLStencilElement {
    }
    var HTMLWcsFieldContentElement: {
        prototype: HTMLWcsFieldContentElement;
        new (): HTMLWcsFieldContentElement;
    };
    interface HTMLWcsFieldLabelElement extends Components.WcsFieldLabel, HTMLStencilElement {
    }
    var HTMLWcsFieldLabelElement: {
        prototype: HTMLWcsFieldLabelElement;
        new (): HTMLWcsFieldLabelElement;
    };
    interface HTMLWcsFooterElement extends Components.WcsFooter, HTMLStencilElement {
    }
    var HTMLWcsFooterElement: {
        prototype: HTMLWcsFooterElement;
        new (): HTMLWcsFooterElement;
    };
    interface HTMLWcsFormFieldElement extends Components.WcsFormField, HTMLStencilElement {
    }
    var HTMLWcsFormFieldElement: {
        prototype: HTMLWcsFormFieldElement;
        new (): HTMLWcsFormFieldElement;
    };
    interface HTMLWcsGalacticElement extends Components.WcsGalactic, HTMLStencilElement {
    }
    var HTMLWcsGalacticElement: {
        prototype: HTMLWcsGalacticElement;
        new (): HTMLWcsGalacticElement;
    };
    interface HTMLWcsGalacticMenuElement extends Components.WcsGalacticMenu, HTMLStencilElement {
    }
    var HTMLWcsGalacticMenuElement: {
        prototype: HTMLWcsGalacticMenuElement;
        new (): HTMLWcsGalacticMenuElement;
    };
    interface HTMLWcsGridElement extends Components.WcsGrid, HTMLStencilElement {
    }
    var HTMLWcsGridElement: {
        prototype: HTMLWcsGridElement;
        new (): HTMLWcsGridElement;
    };
    interface HTMLWcsGridColumnElement extends Components.WcsGridColumn, HTMLStencilElement {
    }
    var HTMLWcsGridColumnElement: {
        prototype: HTMLWcsGridColumnElement;
        new (): HTMLWcsGridColumnElement;
    };
    interface HTMLWcsGridCustomCellElement extends Components.WcsGridCustomCell, HTMLStencilElement {
    }
    var HTMLWcsGridCustomCellElement: {
        prototype: HTMLWcsGridCustomCellElement;
        new (): HTMLWcsGridCustomCellElement;
    };
    interface HTMLWcsGridPaginationElement extends Components.WcsGridPagination, HTMLStencilElement {
    }
    var HTMLWcsGridPaginationElement: {
        prototype: HTMLWcsGridPaginationElement;
        new (): HTMLWcsGridPaginationElement;
    };
    interface HTMLWcsHeaderElement extends Components.WcsHeader, HTMLStencilElement {
    }
    var HTMLWcsHeaderElement: {
        prototype: HTMLWcsHeaderElement;
        new (): HTMLWcsHeaderElement;
    };
    interface HTMLWcsHintElement extends Components.WcsHint, HTMLStencilElement {
    }
    var HTMLWcsHintElement: {
        prototype: HTMLWcsHintElement;
        new (): HTMLWcsHintElement;
    };
    interface HTMLWcsHorizontalStepperElement extends Components.WcsHorizontalStepper, HTMLStencilElement {
    }
    var HTMLWcsHorizontalStepperElement: {
        prototype: HTMLWcsHorizontalStepperElement;
        new (): HTMLWcsHorizontalStepperElement;
    };
    interface HTMLWcsIconElement extends Components.WcsIcon, HTMLStencilElement {
    }
    var HTMLWcsIconElement: {
        prototype: HTMLWcsIconElement;
        new (): HTMLWcsIconElement;
    };
    interface HTMLWcsInputElement extends Components.WcsInput, HTMLStencilElement {
    }
    var HTMLWcsInputElement: {
        prototype: HTMLWcsInputElement;
        new (): HTMLWcsInputElement;
    };
    interface HTMLWcsLabelElement extends Components.WcsLabel, HTMLStencilElement {
    }
    var HTMLWcsLabelElement: {
        prototype: HTMLWcsLabelElement;
        new (): HTMLWcsLabelElement;
    };
    interface HTMLWcsListItemElement extends Components.WcsListItem, HTMLStencilElement {
    }
    var HTMLWcsListItemElement: {
        prototype: HTMLWcsListItemElement;
        new (): HTMLWcsListItemElement;
    };
    interface HTMLWcsListItemPropertiesElement extends Components.WcsListItemProperties, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertiesElement: {
        prototype: HTMLWcsListItemPropertiesElement;
        new (): HTMLWcsListItemPropertiesElement;
    };
    interface HTMLWcsListItemPropertyElement extends Components.WcsListItemProperty, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertyElement: {
        prototype: HTMLWcsListItemPropertyElement;
        new (): HTMLWcsListItemPropertyElement;
    };
    interface HTMLWcsMatIconElement extends Components.WcsMatIcon, HTMLStencilElement {
    }
    var HTMLWcsMatIconElement: {
        prototype: HTMLWcsMatIconElement;
        new (): HTMLWcsMatIconElement;
    };
    interface HTMLWcsModalElement extends Components.WcsModal, HTMLStencilElement {
    }
    var HTMLWcsModalElement: {
        prototype: HTMLWcsModalElement;
        new (): HTMLWcsModalElement;
    };
    interface HTMLWcsNavElement extends Components.WcsNav, HTMLStencilElement {
    }
    var HTMLWcsNavElement: {
        prototype: HTMLWcsNavElement;
        new (): HTMLWcsNavElement;
    };
    interface HTMLWcsNavItemElement extends Components.WcsNavItem, HTMLStencilElement {
    }
    var HTMLWcsNavItemElement: {
        prototype: HTMLWcsNavItemElement;
        new (): HTMLWcsNavItemElement;
    };
    interface HTMLWcsProgressBarElement extends Components.WcsProgressBar, HTMLStencilElement {
    }
    var HTMLWcsProgressBarElement: {
        prototype: HTMLWcsProgressBarElement;
        new (): HTMLWcsProgressBarElement;
    };
    interface HTMLWcsProgressRadialElement extends Components.WcsProgressRadial, HTMLStencilElement {
    }
    var HTMLWcsProgressRadialElement: {
        prototype: HTMLWcsProgressRadialElement;
        new (): HTMLWcsProgressRadialElement;
    };
    interface HTMLWcsRadioElement extends Components.WcsRadio, HTMLStencilElement {
    }
    var HTMLWcsRadioElement: {
        prototype: HTMLWcsRadioElement;
        new (): HTMLWcsRadioElement;
    };
    interface HTMLWcsRadioGroupElement extends Components.WcsRadioGroup, HTMLStencilElement {
    }
    var HTMLWcsRadioGroupElement: {
        prototype: HTMLWcsRadioGroupElement;
        new (): HTMLWcsRadioGroupElement;
    };
    interface HTMLWcsSelectElement extends Components.WcsSelect, HTMLStencilElement {
    }
    var HTMLWcsSelectElement: {
        prototype: HTMLWcsSelectElement;
        new (): HTMLWcsSelectElement;
    };
    interface HTMLWcsSelectOptionElement extends Components.WcsSelectOption, HTMLStencilElement {
    }
    var HTMLWcsSelectOptionElement: {
        prototype: HTMLWcsSelectOptionElement;
        new (): HTMLWcsSelectOptionElement;
    };
    interface HTMLWcsSpinnerElement extends Components.WcsSpinner, HTMLStencilElement {
    }
    var HTMLWcsSpinnerElement: {
        prototype: HTMLWcsSpinnerElement;
        new (): HTMLWcsSpinnerElement;
    };
    interface HTMLWcsSwitchElement extends Components.WcsSwitch, HTMLStencilElement {
    }
    var HTMLWcsSwitchElement: {
        prototype: HTMLWcsSwitchElement;
        new (): HTMLWcsSwitchElement;
    };
    interface HTMLWcsTabElement extends Components.WcsTab, HTMLStencilElement {
    }
    var HTMLWcsTabElement: {
        prototype: HTMLWcsTabElement;
        new (): HTMLWcsTabElement;
    };
    interface HTMLWcsTabsElement extends Components.WcsTabs, HTMLStencilElement {
    }
    var HTMLWcsTabsElement: {
        prototype: HTMLWcsTabsElement;
        new (): HTMLWcsTabsElement;
    };
    interface HTMLWcsTextareaElement extends Components.WcsTextarea, HTMLStencilElement {
    }
    var HTMLWcsTextareaElement: {
        prototype: HTMLWcsTextareaElement;
        new (): HTMLWcsTextareaElement;
    };
    interface HTMLWcsTooltipElement extends Components.WcsTooltip, HTMLStencilElement {
    }
    var HTMLWcsTooltipElement: {
        prototype: HTMLWcsTooltipElement;
        new (): HTMLWcsTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "wcs-accordion": HTMLWcsAccordionElement;
        "wcs-accordion-content": HTMLWcsAccordionContentElement;
        "wcs-accordion-header": HTMLWcsAccordionHeaderElement;
        "wcs-accordion-panel": HTMLWcsAccordionPanelElement;
        "wcs-action-bar": HTMLWcsActionBarElement;
        "wcs-app": HTMLWcsAppElement;
        "wcs-badge": HTMLWcsBadgeElement;
        "wcs-button": HTMLWcsButtonElement;
        "wcs-card": HTMLWcsCardElement;
        "wcs-card-body": HTMLWcsCardBodyElement;
        "wcs-checkbox": HTMLWcsCheckboxElement;
        "wcs-com-nav": HTMLWcsComNavElement;
        "wcs-com-nav-category": HTMLWcsComNavCategoryElement;
        "wcs-com-nav-submenu": HTMLWcsComNavSubmenuElement;
        "wcs-divider": HTMLWcsDividerElement;
        "wcs-dropdown": HTMLWcsDropdownElement;
        "wcs-dropdown-divider": HTMLWcsDropdownDividerElement;
        "wcs-dropdown-header": HTMLWcsDropdownHeaderElement;
        "wcs-dropdown-item": HTMLWcsDropdownItemElement;
        "wcs-editable-field": HTMLWcsEditableFieldElement;
        "wcs-error": HTMLWcsErrorElement;
        "wcs-field": HTMLWcsFieldElement;
        "wcs-field-content": HTMLWcsFieldContentElement;
        "wcs-field-label": HTMLWcsFieldLabelElement;
        "wcs-footer": HTMLWcsFooterElement;
        "wcs-form-field": HTMLWcsFormFieldElement;
        "wcs-galactic": HTMLWcsGalacticElement;
        "wcs-galactic-menu": HTMLWcsGalacticMenuElement;
        "wcs-grid": HTMLWcsGridElement;
        "wcs-grid-column": HTMLWcsGridColumnElement;
        "wcs-grid-custom-cell": HTMLWcsGridCustomCellElement;
        "wcs-grid-pagination": HTMLWcsGridPaginationElement;
        "wcs-header": HTMLWcsHeaderElement;
        "wcs-hint": HTMLWcsHintElement;
        "wcs-horizontal-stepper": HTMLWcsHorizontalStepperElement;
        "wcs-icon": HTMLWcsIconElement;
        "wcs-input": HTMLWcsInputElement;
        "wcs-label": HTMLWcsLabelElement;
        "wcs-list-item": HTMLWcsListItemElement;
        "wcs-list-item-properties": HTMLWcsListItemPropertiesElement;
        "wcs-list-item-property": HTMLWcsListItemPropertyElement;
        "wcs-mat-icon": HTMLWcsMatIconElement;
        "wcs-modal": HTMLWcsModalElement;
        "wcs-nav": HTMLWcsNavElement;
        "wcs-nav-item": HTMLWcsNavItemElement;
        "wcs-progress-bar": HTMLWcsProgressBarElement;
        "wcs-progress-radial": HTMLWcsProgressRadialElement;
        "wcs-radio": HTMLWcsRadioElement;
        "wcs-radio-group": HTMLWcsRadioGroupElement;
        "wcs-select": HTMLWcsSelectElement;
        "wcs-select-option": HTMLWcsSelectOptionElement;
        "wcs-spinner": HTMLWcsSpinnerElement;
        "wcs-switch": HTMLWcsSwitchElement;
        "wcs-tab": HTMLWcsTabElement;
        "wcs-tabs": HTMLWcsTabsElement;
        "wcs-textarea": HTMLWcsTextareaElement;
        "wcs-tooltip": HTMLWcsTooltipElement;
    }
}
declare namespace LocalJSX {
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight"?: boolean;
    }
    interface WcsAccordionContent {
    }
    interface WcsAccordionHeader {
    }
    interface WcsAccordionPanel {
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight"?: boolean;
        "onWcsOpenChange"?: (event: WcsAccordionPanelCustomEvent<boolean>) => void;
        "open"?: boolean;
    }
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter"?: boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color"?: BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape"?: BadgeShape;
    }
    interface WcsButton {
        /**
          * Specify wether the button is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Set a URL to point to. If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading"?: boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode"?: WcsButtonMode;
        /**
          * Specify wether the button should have a ripple effect or not.
         */
        "ripple"?: boolean;
        /**
          * Specify the shape of the button.
         */
        "shape"?: WcsButtonShape;
        /**
          * Specify the button type.
         */
        "type"?: WcsButtonType;
    }
    interface WcsCard {
        "mode"?: CardMode;
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment"?: CheckboxLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
    }
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName"?: string;
    }
    interface WcsComNavCategory {
        "label"?: string;
        "onWcsCategoryItemClicked"?: (event: WcsComNavCategoryCustomEvent<UIEvent>) => void;
        "onWcsCategoryOpened"?: (event: WcsComNavCategoryCustomEvent<CategoryOpenedEventDetail>) => void;
    }
    interface WcsComNavSubmenu {
        "label"?: string;
        /**
          * Emitted when a user click on a final navigation action.  Used by the com-nav component to close the mobile menu overlay when a user click on a final action.
         */
        "onWcsClickOnFinalAction"?: (event: WcsComNavSubmenuCustomEvent<void>) => void;
        "onWcsSubmenuOpened"?: (event: WcsComNavSubmenuCustomEvent<MenuOpenedEventDetail>) => void;
        "panelDescription"?: string;
        "panelTitle"?: string;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled"?: boolean;
        /**
          * Dropdown's button mode
         */
        "mode"?: WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow"?: boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement"?: WcsDropdownPlacement;
        /**
          * Dropdown's button shape
         */
        "shape"?: WcsButtonShape;
    }
    interface WcsDropdownDivider {
    }
    interface WcsDropdownHeader {
    }
    interface WcsDropdownItem {
        "onWcsDropdownItemClick"?: (event: WcsDropdownItemCustomEvent<void>) => void;
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg"?: string;
        /**
          * Function used to format the value
         */
        "formatFn"?: FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * event called at each (valid) update of the field.
         */
        "onWcsChange"?: (event: WcsEditableFieldCustomEvent<EditableComponentUpdateEvent>) => void;
        /**
          * Specify whether the field is editable or not
         */
        "readonly"?: boolean;
        /**
          * Specifies which component is used for editing
         */
        "type"?: EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn"?: ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value"?: any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError"?: boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text"?: string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text"?: string;
    }
    interface WcsGrid {
        "data"?: any[];
        /**
          * Flag to display spinner during data loading
         */
        "loading"?: boolean;
        /**
          * Event emitted when all rows are selected or unselected
         */
        "onWcsGridAllSelectionChange"?: (event: WcsGridCustomEvent<WcsGridAllRowSelectedEventDetails>) => void;
        /**
          * Event emitted when a row is selected or unselected
         */
        "onWcsGridSelectionChange"?: (event: WcsGridCustomEvent<WcsGridRowSelectedEventDetails>) => void;
        /**
          * Name of the object's key that will be used to display the cells whose keyValue attribute matches to the object's value for this key.
         */
        "rowIdPath"?: string;
        /**
          * Set the selected items
         */
        "selectedItems"?: any | any[];
        /**
          * Used to manage grid's row selection
         */
        "selectionConfig"?: WcsGridSelectionConfig;
        /**
          * True to manage sort and pagination with a backend server, default: false
         */
        "serverMode"?: boolean;
        "wcsGridPaginationId"?: string;
    }
    interface WcsGridColumn {
        "customCells"?: boolean;
        "formatter"?: WcsCellFormatter;
        "hidden"?: boolean;
        "name"?: string;
        "onWcsHiddenChange"?: (event: WcsGridColumnCustomEvent<boolean>) => void;
        "onWcsSortChange"?: (event: WcsGridColumnCustomEvent<WcsGridColumnSortChangeEventDetails>) => void;
        "path"?: string;
        "sort"?: boolean;
        "sortFn"?: WcsSortFn;
        "sortOrder"?: WcsSortOrder;
        /**
          * Set the column <th> element width
         */
        "width"?: string;
    }
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId"?: string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId"?: any;
    }
    interface WcsGridPagination {
        "availablePageSizes"?: number[];
        "currentPage"?: number;
        "itemsCount"?: number;
        "onWcsGridPaginationChange"?: (event: WcsGridPaginationCustomEvent<WcsGridPaginationChangeEventDetails>) => void;
        "pageCount"?: number;
        "pageSize"?: number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        "small"?: boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete"?: boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep"?: number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode"?: HorizontalStepperMode;
        /**
          * Emits when the user selects a new step.
         */
        "onWcsHorizontalStepClick"?: (event: WcsHorizontalStepperCustomEvent<HorizontalStepClickEvent>) => void;
        /**
          * steps to display
         */
        "steps"?: HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon"?: string;
        "size"?: 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsInputCustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: WcsInputCustomEvent<KeyboardEvent>) => void;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required"?: boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated"?: boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family"?: MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon"?: string;
        /**
          * Size of the icon
         */
        "size"?: MaterialIconSize;
    }
    interface WcsModal {
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions"?: boolean;
        /**
          * Triggered when the user leaves the dialog with the closing button.
         */
        "onWcsDialogClosed"?: (event: WcsModalCustomEvent<void>) => void;
        /**
          * Displays the modal
         */
        "show"?: boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton"?: boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size"?: ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop"?: boolean;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href"?: string;
        /**
          * This attribute specify the text of the item.
         */
        "text"?: string;
    }
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel"?: boolean;
        /**
          * Whether the component display the small version
         */
        "small"?: boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value"?: number;
    }
    interface WcsProgressRadial {
        "showLabel"?: boolean;
        "size"?: number;
        "value"?: number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked"?: boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled"?: boolean;
        "label"?: string;
        "mode"?: RadioGroupMode;
        "onWcsRadioClick"?: (event: WcsRadioCustomEvent<RadioChosedEvent>) => void;
        "value"?: any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode"?: RadioGroupMode;
        "name"?: any;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        "value"?: any | any[] | undefined | null;
    }
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips"?: boolean;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the select loses focus.
         */
        "onWcsBlur"?: (event: WcsSelectCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsSelectCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the select has focus.
         */
        "onWcsFocus"?: (event: WcsSelectCustomEvent<void>) => void;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled"?: boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple"?: boolean;
        "onWcsSelectOptionClick"?: (event: WcsSelectOptionCustomEvent<SelectOptionChosedEvent>) => void;
        /**
          * Wether this option is selected.
         */
        "selected"?: boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode"?: WcsSpinnerMode;
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment"?: SwitchLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsSwitchCustomEvent<SwitchChangeEventDetail>) => void;
    }
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header"?: string;
        "itemKey"?: any;
        /**
          * Do not use, meant for internal use only.
          * @inner 
          * @ignore
         */
        "onTabLoaded"?: (event: WcsTabCustomEvent<void>) => void;
    }
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align"?: WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter"?: boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly"?: boolean;
        /**
          * Emitted when the selected tab change.
         */
        "onTabChange"?: (event: WcsTabsCustomEvent<WcsTabChangeEvent>) => void;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex"?: number;
        "selectedKey"?: any;
    }
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow"?: boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize"?: string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input value has changed.
         */
        "onWcsChange"?: (event: WcsTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: WcsTextareaCustomEvent<KeyboardEvent>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo"?: WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content"?: string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay"?: number | [number, number];
        /**
          * Duration in ms of the transition animation.
         */
        "duration"?: number | [number, number];
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for"?: string;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive"?: boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.
         */
        "maxWidth"?: string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position"?: WcsTooltipPosition;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme"?: string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger"?: string;
    }
    interface IntrinsicElements {
        "wcs-accordion": WcsAccordion;
        "wcs-accordion-content": WcsAccordionContent;
        "wcs-accordion-header": WcsAccordionHeader;
        "wcs-accordion-panel": WcsAccordionPanel;
        "wcs-action-bar": WcsActionBar;
        "wcs-app": WcsApp;
        "wcs-badge": WcsBadge;
        "wcs-button": WcsButton;
        "wcs-card": WcsCard;
        "wcs-card-body": WcsCardBody;
        "wcs-checkbox": WcsCheckbox;
        "wcs-com-nav": WcsComNav;
        "wcs-com-nav-category": WcsComNavCategory;
        "wcs-com-nav-submenu": WcsComNavSubmenu;
        "wcs-divider": WcsDivider;
        "wcs-dropdown": WcsDropdown;
        "wcs-dropdown-divider": WcsDropdownDivider;
        "wcs-dropdown-header": WcsDropdownHeader;
        "wcs-dropdown-item": WcsDropdownItem;
        "wcs-editable-field": WcsEditableField;
        "wcs-error": WcsError;
        "wcs-field": WcsField;
        "wcs-field-content": WcsFieldContent;
        "wcs-field-label": WcsFieldLabel;
        "wcs-footer": WcsFooter;
        "wcs-form-field": WcsFormField;
        "wcs-galactic": WcsGalactic;
        "wcs-galactic-menu": WcsGalacticMenu;
        "wcs-grid": WcsGrid;
        "wcs-grid-column": WcsGridColumn;
        "wcs-grid-custom-cell": WcsGridCustomCell;
        "wcs-grid-pagination": WcsGridPagination;
        "wcs-header": WcsHeader;
        "wcs-hint": WcsHint;
        "wcs-horizontal-stepper": WcsHorizontalStepper;
        "wcs-icon": WcsIcon;
        "wcs-input": WcsInput;
        "wcs-label": WcsLabel;
        "wcs-list-item": WcsListItem;
        "wcs-list-item-properties": WcsListItemProperties;
        "wcs-list-item-property": WcsListItemProperty;
        "wcs-mat-icon": WcsMatIcon;
        "wcs-modal": WcsModal;
        "wcs-nav": WcsNav;
        "wcs-nav-item": WcsNavItem;
        "wcs-progress-bar": WcsProgressBar;
        "wcs-progress-radial": WcsProgressRadial;
        "wcs-radio": WcsRadio;
        "wcs-radio-group": WcsRadioGroup;
        "wcs-select": WcsSelect;
        "wcs-select-option": WcsSelectOption;
        "wcs-spinner": WcsSpinner;
        "wcs-switch": WcsSwitch;
        "wcs-tab": WcsTab;
        "wcs-tabs": WcsTabs;
        "wcs-textarea": WcsTextarea;
        "wcs-tooltip": WcsTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wcs-accordion": LocalJSX.WcsAccordion & JSXBase.HTMLAttributes<HTMLWcsAccordionElement>;
            "wcs-accordion-content": LocalJSX.WcsAccordionContent & JSXBase.HTMLAttributes<HTMLWcsAccordionContentElement>;
            "wcs-accordion-header": LocalJSX.WcsAccordionHeader & JSXBase.HTMLAttributes<HTMLWcsAccordionHeaderElement>;
            "wcs-accordion-panel": LocalJSX.WcsAccordionPanel & JSXBase.HTMLAttributes<HTMLWcsAccordionPanelElement>;
            "wcs-action-bar": LocalJSX.WcsActionBar & JSXBase.HTMLAttributes<HTMLWcsActionBarElement>;
            "wcs-app": LocalJSX.WcsApp & JSXBase.HTMLAttributes<HTMLWcsAppElement>;
            "wcs-badge": LocalJSX.WcsBadge & JSXBase.HTMLAttributes<HTMLWcsBadgeElement>;
            "wcs-button": LocalJSX.WcsButton & JSXBase.HTMLAttributes<HTMLWcsButtonElement>;
            "wcs-card": LocalJSX.WcsCard & JSXBase.HTMLAttributes<HTMLWcsCardElement>;
            "wcs-card-body": LocalJSX.WcsCardBody & JSXBase.HTMLAttributes<HTMLWcsCardBodyElement>;
            "wcs-checkbox": LocalJSX.WcsCheckbox & JSXBase.HTMLAttributes<HTMLWcsCheckboxElement>;
            "wcs-com-nav": LocalJSX.WcsComNav & JSXBase.HTMLAttributes<HTMLWcsComNavElement>;
            "wcs-com-nav-category": LocalJSX.WcsComNavCategory & JSXBase.HTMLAttributes<HTMLWcsComNavCategoryElement>;
            "wcs-com-nav-submenu": LocalJSX.WcsComNavSubmenu & JSXBase.HTMLAttributes<HTMLWcsComNavSubmenuElement>;
            "wcs-divider": LocalJSX.WcsDivider & JSXBase.HTMLAttributes<HTMLWcsDividerElement>;
            "wcs-dropdown": LocalJSX.WcsDropdown & JSXBase.HTMLAttributes<HTMLWcsDropdownElement>;
            "wcs-dropdown-divider": LocalJSX.WcsDropdownDivider & JSXBase.HTMLAttributes<HTMLWcsDropdownDividerElement>;
            "wcs-dropdown-header": LocalJSX.WcsDropdownHeader & JSXBase.HTMLAttributes<HTMLWcsDropdownHeaderElement>;
            "wcs-dropdown-item": LocalJSX.WcsDropdownItem & JSXBase.HTMLAttributes<HTMLWcsDropdownItemElement>;
            "wcs-editable-field": LocalJSX.WcsEditableField & JSXBase.HTMLAttributes<HTMLWcsEditableFieldElement>;
            "wcs-error": LocalJSX.WcsError & JSXBase.HTMLAttributes<HTMLWcsErrorElement>;
            "wcs-field": LocalJSX.WcsField & JSXBase.HTMLAttributes<HTMLWcsFieldElement>;
            "wcs-field-content": LocalJSX.WcsFieldContent & JSXBase.HTMLAttributes<HTMLWcsFieldContentElement>;
            "wcs-field-label": LocalJSX.WcsFieldLabel & JSXBase.HTMLAttributes<HTMLWcsFieldLabelElement>;
            "wcs-footer": LocalJSX.WcsFooter & JSXBase.HTMLAttributes<HTMLWcsFooterElement>;
            "wcs-form-field": LocalJSX.WcsFormField & JSXBase.HTMLAttributes<HTMLWcsFormFieldElement>;
            "wcs-galactic": LocalJSX.WcsGalactic & JSXBase.HTMLAttributes<HTMLWcsGalacticElement>;
            "wcs-galactic-menu": LocalJSX.WcsGalacticMenu & JSXBase.HTMLAttributes<HTMLWcsGalacticMenuElement>;
            "wcs-grid": LocalJSX.WcsGrid & JSXBase.HTMLAttributes<HTMLWcsGridElement>;
            "wcs-grid-column": LocalJSX.WcsGridColumn & JSXBase.HTMLAttributes<HTMLWcsGridColumnElement>;
            "wcs-grid-custom-cell": LocalJSX.WcsGridCustomCell & JSXBase.HTMLAttributes<HTMLWcsGridCustomCellElement>;
            "wcs-grid-pagination": LocalJSX.WcsGridPagination & JSXBase.HTMLAttributes<HTMLWcsGridPaginationElement>;
            "wcs-header": LocalJSX.WcsHeader & JSXBase.HTMLAttributes<HTMLWcsHeaderElement>;
            "wcs-hint": LocalJSX.WcsHint & JSXBase.HTMLAttributes<HTMLWcsHintElement>;
            "wcs-horizontal-stepper": LocalJSX.WcsHorizontalStepper & JSXBase.HTMLAttributes<HTMLWcsHorizontalStepperElement>;
            "wcs-icon": LocalJSX.WcsIcon & JSXBase.HTMLAttributes<HTMLWcsIconElement>;
            "wcs-input": LocalJSX.WcsInput & JSXBase.HTMLAttributes<HTMLWcsInputElement>;
            "wcs-label": LocalJSX.WcsLabel & JSXBase.HTMLAttributes<HTMLWcsLabelElement>;
            "wcs-list-item": LocalJSX.WcsListItem & JSXBase.HTMLAttributes<HTMLWcsListItemElement>;
            "wcs-list-item-properties": LocalJSX.WcsListItemProperties & JSXBase.HTMLAttributes<HTMLWcsListItemPropertiesElement>;
            "wcs-list-item-property": LocalJSX.WcsListItemProperty & JSXBase.HTMLAttributes<HTMLWcsListItemPropertyElement>;
            "wcs-mat-icon": LocalJSX.WcsMatIcon & JSXBase.HTMLAttributes<HTMLWcsMatIconElement>;
            "wcs-modal": LocalJSX.WcsModal & JSXBase.HTMLAttributes<HTMLWcsModalElement>;
            "wcs-nav": LocalJSX.WcsNav & JSXBase.HTMLAttributes<HTMLWcsNavElement>;
            "wcs-nav-item": LocalJSX.WcsNavItem & JSXBase.HTMLAttributes<HTMLWcsNavItemElement>;
            "wcs-progress-bar": LocalJSX.WcsProgressBar & JSXBase.HTMLAttributes<HTMLWcsProgressBarElement>;
            "wcs-progress-radial": LocalJSX.WcsProgressRadial & JSXBase.HTMLAttributes<HTMLWcsProgressRadialElement>;
            "wcs-radio": LocalJSX.WcsRadio & JSXBase.HTMLAttributes<HTMLWcsRadioElement>;
            "wcs-radio-group": LocalJSX.WcsRadioGroup & JSXBase.HTMLAttributes<HTMLWcsRadioGroupElement>;
            "wcs-select": LocalJSX.WcsSelect & JSXBase.HTMLAttributes<HTMLWcsSelectElement>;
            "wcs-select-option": LocalJSX.WcsSelectOption & JSXBase.HTMLAttributes<HTMLWcsSelectOptionElement>;
            "wcs-spinner": LocalJSX.WcsSpinner & JSXBase.HTMLAttributes<HTMLWcsSpinnerElement>;
            "wcs-switch": LocalJSX.WcsSwitch & JSXBase.HTMLAttributes<HTMLWcsSwitchElement>;
            "wcs-tab": LocalJSX.WcsTab & JSXBase.HTMLAttributes<HTMLWcsTabElement>;
            "wcs-tabs": LocalJSX.WcsTabs & JSXBase.HTMLAttributes<HTMLWcsTabsElement>;
            "wcs-textarea": LocalJSX.WcsTextarea & JSXBase.HTMLAttributes<HTMLWcsTextareaElement>;
            "wcs-tooltip": LocalJSX.WcsTooltip & JSXBase.HTMLAttributes<HTMLWcsTooltipElement>;
        }
    }
}
