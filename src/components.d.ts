/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { WcsButtonMode, WcsButtonShape, WcsButtonType } from "./components/button/button-interface";
import { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
import { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
import { EditableComponentUpdateEvent, FormatFn, ValidateFn } from "./components/editable-field/editable-field-interface";
import { WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridRowSelectedEventDetails, WcsGridSelectionConfig, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
import { HorizontalStepClickEvent, HorizontalStepConfig } from "./components/horizontal-stepper/horizontal-stepper-interface";
import { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes } from "./components/input/input-interface";
import { MaterialIconFamily } from "./components/mat-icon/mat-icon-interface";
import { RadioChosedEvent } from "./components/radio/radio-interface";
import { RadioGroupChangeEventDetail } from "./components/radio-group/radio-group-interface";
import { SelectChangeEventDetail } from "./components/select/select-interface";
import { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
import { SwitchChangeEventDetail } from "./components/switch/switch-interface";
import { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
import { TextareaChangeEventDetail } from "./components/textarea/textarea-interface";
import { WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export namespace Components {
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter": boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color": 'initial' | 'lighter';
        /**
          * Define the shape of the badge
         */
        "shape": 'normal' | 'rounded';
    }
    interface WcsButton {
        /**
          * Specify wether the button is disabled or not.
         */
        "disabled": boolean;
        /**
          * Set a URL to point to. If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode": WcsButtonMode;
        /**
          * Specify wether the button should have a ripple effect or not.
         */
        "ripple": boolean;
        /**
          * Specify the shape of the button.
         */
        "shape": WcsButtonShape;
        /**
          * Specify the button type.
         */
        "type": WcsButtonType;
    }
    interface WcsCard {
        "mode": 'flat' | 'raised';
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment": CheckboxLabelAlignment;
        "name": string;
    }
    interface WcsComNav {
        "appName": string;
    }
    interface WcsComNavCategory {
        /**
          * Close the category
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the category
         */
        "open": () => Promise<void>;
    }
    interface WcsComNavSubmenu {
        /**
          * Close the menu
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the menu
         */
        "open": () => Promise<void>;
        "panelDescription": string;
        "panelTitle": string;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        "disabled": boolean;
        "mode": WcsButtonMode;
        "shape": WcsButtonShape;
    }
    interface WcsDropdownItem {
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg": string;
        /**
          * Function used to format the value
         */
        "formatFn": FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * Specify whether the field is editable or not
         */
        "readonly": boolean;
        /**
          * Specifies which component is used for editing
         */
        "type": 'input' | 'textarea' | 'select';
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn": ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value": any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    interface WcsFormField {
        /**
          * Name of the material icon to add to the field
         */
        "icon": any;
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError": boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text": string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text": string;
    }
    interface WcsGrid {
        "data": any[];
        /**
          * Flag to display spinner during data loading
         */
        "loading": boolean;
        /**
          * Name of the object's key that will be used to display the cells whose keyValue attribute matches to the object's value for this key.
         */
        "rowIdPath": string;
        /**
          * Set the selected items
         */
        "selectedItems": any | any[];
        /**
          * Used to manage grid's row selection
         */
        "selectionConfig": WcsGridSelectionConfig;
        /**
          * True to manage sort and pagination with a backend server, default: false
         */
        "serverMode": boolean;
        "wcsGridPaginationId": string;
    }
    interface WcsGridColumn {
        "customCells": boolean;
        "formatter": WcsCellFormatter;
        "hidden": boolean;
        "name": string;
        "path": string;
        "sort": boolean;
        "sortFn": WcsSortFn;
        "sortOrder": WcsSortOrder;
        /**
          * Set the column <th> element width
         */
        "width": string;
    }
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId": string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId": any;
    }
    interface WcsGridPagination {
        "availablePageSizes": number[];
        "currentPage": number;
        "itemsCount": number;
        "pageCount": number;
        "pageSize": number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        "small": boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete": boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep": number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode": 'linear' | 'nonLinear';
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        /**
          * steps to display
         */
        "steps": HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon": string;
        "size": 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Sets blur on the native `input` in `wcs-input`. Use this method instead of the global `input.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `input` in `wcs-input`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required": boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated": boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family": MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon": string;
        /**
          * Size of the icon
         */
        "size": 's' | 'm' | 'l' | 'xl';
    }
    interface WcsModal {
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "backdrop": boolean;
        /**
          * Displays the modal
         */
        "show": boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton": boolean;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href": string;
        /**
          * This attribute specify the text of the item.
         */
        "text": string;
    }
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel": boolean;
        /**
          * Whether the component display the small version
         */
        "small": boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value": number;
    }
    interface WcsProgressRadial {
        "showLabel": boolean;
        "size": number;
        "value": number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked": boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled": boolean;
        "label": string;
        "mode": 'radio' | 'option';
        "value": any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode": 'radio' | 'option';
        "name": any;
        "value": any | any[] | undefined | null;
    }
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips": boolean;
        /**
          * Close the component.
         */
        "close": () => Promise<void>;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled": boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Open the component.
         */
        "open": () => Promise<void>;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled": boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple": boolean;
        /**
          * Wether this option is selected.
         */
        "selected": boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode": 'border' | 'growing';
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked": boolean;
        "name": string;
    }
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header": string;
        "itemKey": any;
    }
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align": WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter": boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly": boolean;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex": number;
        "selectedKey": any;
    }
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow": boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize": string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit": boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * This method make the textarea automatically adopt the size of the content without a scroll bar
         */
        "fitContent": () => Promise<void>;
        /**
          * Returns the native `<textarea>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * Sets blur on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface WcsTooltip {
        /**
          * The **id** of the element the tooltip's going to describe.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for": string;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position": WcsTooltipPosition;
    }
}
declare global {
    interface HTMLWcsActionBarElement extends Components.WcsActionBar, HTMLStencilElement {
    }
    var HTMLWcsActionBarElement: {
        prototype: HTMLWcsActionBarElement;
        new (): HTMLWcsActionBarElement;
    };
    interface HTMLWcsAppElement extends Components.WcsApp, HTMLStencilElement {
    }
    var HTMLWcsAppElement: {
        prototype: HTMLWcsAppElement;
        new (): HTMLWcsAppElement;
    };
    interface HTMLWcsBadgeElement extends Components.WcsBadge, HTMLStencilElement {
    }
    var HTMLWcsBadgeElement: {
        prototype: HTMLWcsBadgeElement;
        new (): HTMLWcsBadgeElement;
    };
    interface HTMLWcsButtonElement extends Components.WcsButton, HTMLStencilElement {
    }
    var HTMLWcsButtonElement: {
        prototype: HTMLWcsButtonElement;
        new (): HTMLWcsButtonElement;
    };
    interface HTMLWcsCardElement extends Components.WcsCard, HTMLStencilElement {
    }
    var HTMLWcsCardElement: {
        prototype: HTMLWcsCardElement;
        new (): HTMLWcsCardElement;
    };
    interface HTMLWcsCardBodyElement extends Components.WcsCardBody, HTMLStencilElement {
    }
    var HTMLWcsCardBodyElement: {
        prototype: HTMLWcsCardBodyElement;
        new (): HTMLWcsCardBodyElement;
    };
    interface HTMLWcsCheckboxElement extends Components.WcsCheckbox, HTMLStencilElement {
    }
    var HTMLWcsCheckboxElement: {
        prototype: HTMLWcsCheckboxElement;
        new (): HTMLWcsCheckboxElement;
    };
    interface HTMLWcsComNavElement extends Components.WcsComNav, HTMLStencilElement {
    }
    var HTMLWcsComNavElement: {
        prototype: HTMLWcsComNavElement;
        new (): HTMLWcsComNavElement;
    };
    interface HTMLWcsComNavCategoryElement extends Components.WcsComNavCategory, HTMLStencilElement {
    }
    var HTMLWcsComNavCategoryElement: {
        prototype: HTMLWcsComNavCategoryElement;
        new (): HTMLWcsComNavCategoryElement;
    };
    interface HTMLWcsComNavSubmenuElement extends Components.WcsComNavSubmenu, HTMLStencilElement {
    }
    var HTMLWcsComNavSubmenuElement: {
        prototype: HTMLWcsComNavSubmenuElement;
        new (): HTMLWcsComNavSubmenuElement;
    };
    interface HTMLWcsDividerElement extends Components.WcsDivider, HTMLStencilElement {
    }
    var HTMLWcsDividerElement: {
        prototype: HTMLWcsDividerElement;
        new (): HTMLWcsDividerElement;
    };
    interface HTMLWcsDropdownElement extends Components.WcsDropdown, HTMLStencilElement {
    }
    var HTMLWcsDropdownElement: {
        prototype: HTMLWcsDropdownElement;
        new (): HTMLWcsDropdownElement;
    };
    interface HTMLWcsDropdownItemElement extends Components.WcsDropdownItem, HTMLStencilElement {
    }
    var HTMLWcsDropdownItemElement: {
        prototype: HTMLWcsDropdownItemElement;
        new (): HTMLWcsDropdownItemElement;
    };
    interface HTMLWcsEditableFieldElement extends Components.WcsEditableField, HTMLStencilElement {
    }
    var HTMLWcsEditableFieldElement: {
        prototype: HTMLWcsEditableFieldElement;
        new (): HTMLWcsEditableFieldElement;
    };
    interface HTMLWcsErrorElement extends Components.WcsError, HTMLStencilElement {
    }
    var HTMLWcsErrorElement: {
        prototype: HTMLWcsErrorElement;
        new (): HTMLWcsErrorElement;
    };
    interface HTMLWcsFieldElement extends Components.WcsField, HTMLStencilElement {
    }
    var HTMLWcsFieldElement: {
        prototype: HTMLWcsFieldElement;
        new (): HTMLWcsFieldElement;
    };
    interface HTMLWcsFieldContentElement extends Components.WcsFieldContent, HTMLStencilElement {
    }
    var HTMLWcsFieldContentElement: {
        prototype: HTMLWcsFieldContentElement;
        new (): HTMLWcsFieldContentElement;
    };
    interface HTMLWcsFieldLabelElement extends Components.WcsFieldLabel, HTMLStencilElement {
    }
    var HTMLWcsFieldLabelElement: {
        prototype: HTMLWcsFieldLabelElement;
        new (): HTMLWcsFieldLabelElement;
    };
    interface HTMLWcsFooterElement extends Components.WcsFooter, HTMLStencilElement {
    }
    var HTMLWcsFooterElement: {
        prototype: HTMLWcsFooterElement;
        new (): HTMLWcsFooterElement;
    };
    interface HTMLWcsFormFieldElement extends Components.WcsFormField, HTMLStencilElement {
    }
    var HTMLWcsFormFieldElement: {
        prototype: HTMLWcsFormFieldElement;
        new (): HTMLWcsFormFieldElement;
    };
    interface HTMLWcsGalacticElement extends Components.WcsGalactic, HTMLStencilElement {
    }
    var HTMLWcsGalacticElement: {
        prototype: HTMLWcsGalacticElement;
        new (): HTMLWcsGalacticElement;
    };
    interface HTMLWcsGalacticMenuElement extends Components.WcsGalacticMenu, HTMLStencilElement {
    }
    var HTMLWcsGalacticMenuElement: {
        prototype: HTMLWcsGalacticMenuElement;
        new (): HTMLWcsGalacticMenuElement;
    };
    interface HTMLWcsGridElement extends Components.WcsGrid, HTMLStencilElement {
    }
    var HTMLWcsGridElement: {
        prototype: HTMLWcsGridElement;
        new (): HTMLWcsGridElement;
    };
    interface HTMLWcsGridColumnElement extends Components.WcsGridColumn, HTMLStencilElement {
    }
    var HTMLWcsGridColumnElement: {
        prototype: HTMLWcsGridColumnElement;
        new (): HTMLWcsGridColumnElement;
    };
    interface HTMLWcsGridCustomCellElement extends Components.WcsGridCustomCell, HTMLStencilElement {
    }
    var HTMLWcsGridCustomCellElement: {
        prototype: HTMLWcsGridCustomCellElement;
        new (): HTMLWcsGridCustomCellElement;
    };
    interface HTMLWcsGridPaginationElement extends Components.WcsGridPagination, HTMLStencilElement {
    }
    var HTMLWcsGridPaginationElement: {
        prototype: HTMLWcsGridPaginationElement;
        new (): HTMLWcsGridPaginationElement;
    };
    interface HTMLWcsHeaderElement extends Components.WcsHeader, HTMLStencilElement {
    }
    var HTMLWcsHeaderElement: {
        prototype: HTMLWcsHeaderElement;
        new (): HTMLWcsHeaderElement;
    };
    interface HTMLWcsHintElement extends Components.WcsHint, HTMLStencilElement {
    }
    var HTMLWcsHintElement: {
        prototype: HTMLWcsHintElement;
        new (): HTMLWcsHintElement;
    };
    interface HTMLWcsHorizontalStepperElement extends Components.WcsHorizontalStepper, HTMLStencilElement {
    }
    var HTMLWcsHorizontalStepperElement: {
        prototype: HTMLWcsHorizontalStepperElement;
        new (): HTMLWcsHorizontalStepperElement;
    };
    interface HTMLWcsIconElement extends Components.WcsIcon, HTMLStencilElement {
    }
    var HTMLWcsIconElement: {
        prototype: HTMLWcsIconElement;
        new (): HTMLWcsIconElement;
    };
    interface HTMLWcsInputElement extends Components.WcsInput, HTMLStencilElement {
    }
    var HTMLWcsInputElement: {
        prototype: HTMLWcsInputElement;
        new (): HTMLWcsInputElement;
    };
    interface HTMLWcsLabelElement extends Components.WcsLabel, HTMLStencilElement {
    }
    var HTMLWcsLabelElement: {
        prototype: HTMLWcsLabelElement;
        new (): HTMLWcsLabelElement;
    };
    interface HTMLWcsListItemElement extends Components.WcsListItem, HTMLStencilElement {
    }
    var HTMLWcsListItemElement: {
        prototype: HTMLWcsListItemElement;
        new (): HTMLWcsListItemElement;
    };
    interface HTMLWcsListItemPropertiesElement extends Components.WcsListItemProperties, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertiesElement: {
        prototype: HTMLWcsListItemPropertiesElement;
        new (): HTMLWcsListItemPropertiesElement;
    };
    interface HTMLWcsListItemPropertyElement extends Components.WcsListItemProperty, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertyElement: {
        prototype: HTMLWcsListItemPropertyElement;
        new (): HTMLWcsListItemPropertyElement;
    };
    interface HTMLWcsMatIconElement extends Components.WcsMatIcon, HTMLStencilElement {
    }
    var HTMLWcsMatIconElement: {
        prototype: HTMLWcsMatIconElement;
        new (): HTMLWcsMatIconElement;
    };
    interface HTMLWcsModalElement extends Components.WcsModal, HTMLStencilElement {
    }
    var HTMLWcsModalElement: {
        prototype: HTMLWcsModalElement;
        new (): HTMLWcsModalElement;
    };
    interface HTMLWcsNavElement extends Components.WcsNav, HTMLStencilElement {
    }
    var HTMLWcsNavElement: {
        prototype: HTMLWcsNavElement;
        new (): HTMLWcsNavElement;
    };
    interface HTMLWcsNavItemElement extends Components.WcsNavItem, HTMLStencilElement {
    }
    var HTMLWcsNavItemElement: {
        prototype: HTMLWcsNavItemElement;
        new (): HTMLWcsNavItemElement;
    };
    interface HTMLWcsProgressBarElement extends Components.WcsProgressBar, HTMLStencilElement {
    }
    var HTMLWcsProgressBarElement: {
        prototype: HTMLWcsProgressBarElement;
        new (): HTMLWcsProgressBarElement;
    };
    interface HTMLWcsProgressRadialElement extends Components.WcsProgressRadial, HTMLStencilElement {
    }
    var HTMLWcsProgressRadialElement: {
        prototype: HTMLWcsProgressRadialElement;
        new (): HTMLWcsProgressRadialElement;
    };
    interface HTMLWcsRadioElement extends Components.WcsRadio, HTMLStencilElement {
    }
    var HTMLWcsRadioElement: {
        prototype: HTMLWcsRadioElement;
        new (): HTMLWcsRadioElement;
    };
    interface HTMLWcsRadioGroupElement extends Components.WcsRadioGroup, HTMLStencilElement {
    }
    var HTMLWcsRadioGroupElement: {
        prototype: HTMLWcsRadioGroupElement;
        new (): HTMLWcsRadioGroupElement;
    };
    interface HTMLWcsSelectElement extends Components.WcsSelect, HTMLStencilElement {
    }
    var HTMLWcsSelectElement: {
        prototype: HTMLWcsSelectElement;
        new (): HTMLWcsSelectElement;
    };
    interface HTMLWcsSelectOptionElement extends Components.WcsSelectOption, HTMLStencilElement {
    }
    var HTMLWcsSelectOptionElement: {
        prototype: HTMLWcsSelectOptionElement;
        new (): HTMLWcsSelectOptionElement;
    };
    interface HTMLWcsSpinnerElement extends Components.WcsSpinner, HTMLStencilElement {
    }
    var HTMLWcsSpinnerElement: {
        prototype: HTMLWcsSpinnerElement;
        new (): HTMLWcsSpinnerElement;
    };
    interface HTMLWcsSwitchElement extends Components.WcsSwitch, HTMLStencilElement {
    }
    var HTMLWcsSwitchElement: {
        prototype: HTMLWcsSwitchElement;
        new (): HTMLWcsSwitchElement;
    };
    interface HTMLWcsTabElement extends Components.WcsTab, HTMLStencilElement {
    }
    var HTMLWcsTabElement: {
        prototype: HTMLWcsTabElement;
        new (): HTMLWcsTabElement;
    };
    interface HTMLWcsTabsElement extends Components.WcsTabs, HTMLStencilElement {
    }
    var HTMLWcsTabsElement: {
        prototype: HTMLWcsTabsElement;
        new (): HTMLWcsTabsElement;
    };
    interface HTMLWcsTextareaElement extends Components.WcsTextarea, HTMLStencilElement {
    }
    var HTMLWcsTextareaElement: {
        prototype: HTMLWcsTextareaElement;
        new (): HTMLWcsTextareaElement;
    };
    interface HTMLWcsTooltipElement extends Components.WcsTooltip, HTMLStencilElement {
    }
    var HTMLWcsTooltipElement: {
        prototype: HTMLWcsTooltipElement;
        new (): HTMLWcsTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "wcs-action-bar": HTMLWcsActionBarElement;
        "wcs-app": HTMLWcsAppElement;
        "wcs-badge": HTMLWcsBadgeElement;
        "wcs-button": HTMLWcsButtonElement;
        "wcs-card": HTMLWcsCardElement;
        "wcs-card-body": HTMLWcsCardBodyElement;
        "wcs-checkbox": HTMLWcsCheckboxElement;
        "wcs-com-nav": HTMLWcsComNavElement;
        "wcs-com-nav-category": HTMLWcsComNavCategoryElement;
        "wcs-com-nav-submenu": HTMLWcsComNavSubmenuElement;
        "wcs-divider": HTMLWcsDividerElement;
        "wcs-dropdown": HTMLWcsDropdownElement;
        "wcs-dropdown-item": HTMLWcsDropdownItemElement;
        "wcs-editable-field": HTMLWcsEditableFieldElement;
        "wcs-error": HTMLWcsErrorElement;
        "wcs-field": HTMLWcsFieldElement;
        "wcs-field-content": HTMLWcsFieldContentElement;
        "wcs-field-label": HTMLWcsFieldLabelElement;
        "wcs-footer": HTMLWcsFooterElement;
        "wcs-form-field": HTMLWcsFormFieldElement;
        "wcs-galactic": HTMLWcsGalacticElement;
        "wcs-galactic-menu": HTMLWcsGalacticMenuElement;
        "wcs-grid": HTMLWcsGridElement;
        "wcs-grid-column": HTMLWcsGridColumnElement;
        "wcs-grid-custom-cell": HTMLWcsGridCustomCellElement;
        "wcs-grid-pagination": HTMLWcsGridPaginationElement;
        "wcs-header": HTMLWcsHeaderElement;
        "wcs-hint": HTMLWcsHintElement;
        "wcs-horizontal-stepper": HTMLWcsHorizontalStepperElement;
        "wcs-icon": HTMLWcsIconElement;
        "wcs-input": HTMLWcsInputElement;
        "wcs-label": HTMLWcsLabelElement;
        "wcs-list-item": HTMLWcsListItemElement;
        "wcs-list-item-properties": HTMLWcsListItemPropertiesElement;
        "wcs-list-item-property": HTMLWcsListItemPropertyElement;
        "wcs-mat-icon": HTMLWcsMatIconElement;
        "wcs-modal": HTMLWcsModalElement;
        "wcs-nav": HTMLWcsNavElement;
        "wcs-nav-item": HTMLWcsNavItemElement;
        "wcs-progress-bar": HTMLWcsProgressBarElement;
        "wcs-progress-radial": HTMLWcsProgressRadialElement;
        "wcs-radio": HTMLWcsRadioElement;
        "wcs-radio-group": HTMLWcsRadioGroupElement;
        "wcs-select": HTMLWcsSelectElement;
        "wcs-select-option": HTMLWcsSelectOptionElement;
        "wcs-spinner": HTMLWcsSpinnerElement;
        "wcs-switch": HTMLWcsSwitchElement;
        "wcs-tab": HTMLWcsTabElement;
        "wcs-tabs": HTMLWcsTabsElement;
        "wcs-textarea": HTMLWcsTextareaElement;
        "wcs-tooltip": HTMLWcsTooltipElement;
    }
}
declare namespace LocalJSX {
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter"?: boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color"?: 'initial' | 'lighter';
        /**
          * Define the shape of the badge
         */
        "shape"?: 'normal' | 'rounded';
    }
    interface WcsButton {
        /**
          * Specify wether the button is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Set a URL to point to. If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode"?: WcsButtonMode;
        /**
          * Specify wether the button should have a ripple effect or not.
         */
        "ripple"?: boolean;
        /**
          * Specify the shape of the button.
         */
        "shape"?: WcsButtonShape;
        /**
          * Specify the button type.
         */
        "type"?: WcsButtonType;
    }
    interface WcsCard {
        "mode"?: 'flat' | 'raised';
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment"?: CheckboxLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: CustomEvent<CheckboxChangeEventDetail>) => void;
    }
    interface WcsComNav {
        "appName"?: string;
    }
    interface WcsComNavCategory {
        "label"?: string;
        "onWcsCategoryItemClicked"?: (event: CustomEvent<MouseEvent>) => void;
        "onWcsCategoryOpened"?: (event: CustomEvent<CategoryOpenedEventDetail>) => void;
    }
    interface WcsComNavSubmenu {
        "label"?: string;
        "onWcsSubmenuOpened"?: (event: CustomEvent<MenuOpenedEventDetail>) => void;
        "panelDescription"?: string;
        "panelTitle"?: string;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        "disabled"?: boolean;
        "mode"?: WcsButtonMode;
        "shape"?: WcsButtonShape;
    }
    interface WcsDropdownItem {
        "onWcsDropdownItemClick"?: (event: CustomEvent<void>) => void;
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg"?: string;
        /**
          * Function used to format the value
         */
        "formatFn"?: FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * event called at each (valid) update of the field.
         */
        "onWcsChange"?: (event: CustomEvent<EditableComponentUpdateEvent>) => void;
        /**
          * Specify whether the field is editable or not
         */
        "readonly"?: boolean;
        /**
          * Specifies which component is used for editing
         */
        "type"?: 'input' | 'textarea' | 'select';
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn"?: ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value"?: any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    interface WcsFormField {
        /**
          * Name of the material icon to add to the field
         */
        "icon"?: any;
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError"?: boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text"?: string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text"?: string;
    }
    interface WcsGrid {
        "data"?: any[];
        /**
          * Flag to display spinner during data loading
         */
        "loading"?: boolean;
        /**
          * Event emitted when all rows are selected or unselected
         */
        "onWcsGridAllSelectionChange"?: (event: CustomEvent<WcsGridAllRowSelectedEventDetails>) => void;
        /**
          * Event emitted when a row is selected or unselected
         */
        "onWcsGridSelectionChange"?: (event: CustomEvent<WcsGridRowSelectedEventDetails>) => void;
        /**
          * Name of the object's key that will be used to display the cells whose keyValue attribute matches to the object's value for this key.
         */
        "rowIdPath"?: string;
        /**
          * Set the selected items
         */
        "selectedItems"?: any | any[];
        /**
          * Used to manage grid's row selection
         */
        "selectionConfig"?: WcsGridSelectionConfig;
        /**
          * True to manage sort and pagination with a backend server, default: false
         */
        "serverMode"?: boolean;
        "wcsGridPaginationId"?: string;
    }
    interface WcsGridColumn {
        "customCells"?: boolean;
        "formatter"?: WcsCellFormatter;
        "hidden"?: boolean;
        "name"?: string;
        "onWcsHiddenChange"?: (event: CustomEvent<boolean>) => void;
        "onWcsSortChange"?: (event: CustomEvent<WcsGridColumnSortChangeEventDetails>) => void;
        "path"?: string;
        "sort"?: boolean;
        "sortFn"?: WcsSortFn;
        "sortOrder"?: WcsSortOrder;
        /**
          * Set the column <th> element width
         */
        "width"?: string;
    }
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId"?: string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId"?: any;
    }
    interface WcsGridPagination {
        "availablePageSizes"?: number[];
        "currentPage"?: number;
        "itemsCount"?: number;
        "onWcsGridPaginationChange"?: (event: CustomEvent<WcsGridPaginationChangeEventDetails>) => void;
        "pageCount"?: number;
        "pageSize"?: number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        "small"?: boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete"?: boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep"?: number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode"?: 'linear' | 'nonLinear';
        /**
          * Emits when the user selects a new step.
         */
        "onWcsHorizontalStepClick"?: (event: CustomEvent<HorizontalStepClickEvent>) => void;
        /**
          * steps to display
         */
        "steps"?: HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon"?: string;
        "size"?: 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: CustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
         */
        "size"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required"?: boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated"?: boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family"?: MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon"?: string;
        /**
          * Size of the icon
         */
        "size"?: 's' | 'm' | 'l' | 'xl';
    }
    interface WcsModal {
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "backdrop"?: boolean;
        /**
          * Triggered when the user leaves the dialog with the closing button.
         */
        "onWcsDialogClosed"?: (event: CustomEvent<void>) => void;
        /**
          * Displays the modal
         */
        "show"?: boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton"?: boolean;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href"?: string;
        /**
          * This attribute specify the text of the item.
         */
        "text"?: string;
    }
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel"?: boolean;
        /**
          * Whether the component display the small version
         */
        "small"?: boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value"?: number;
    }
    interface WcsProgressRadial {
        "showLabel"?: boolean;
        "size"?: number;
        "value"?: number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked"?: boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled"?: boolean;
        "label"?: string;
        "mode"?: 'radio' | 'option';
        "onWcsRadioClick"?: (event: CustomEvent<RadioChosedEvent>) => void;
        "value"?: any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode"?: 'radio' | 'option';
        "name"?: any;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: CustomEvent<RadioGroupChangeEventDetail>) => void;
        "value"?: any | any[] | undefined | null;
    }
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips"?: boolean;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the select loses focus.
         */
        "onWcsBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: CustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the select has focus.
         */
        "onWcsFocus"?: (event: CustomEvent<void>) => void;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled"?: boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple"?: boolean;
        "onWcsSelectOptionClick"?: (event: CustomEvent<SelectOptionChosedEvent>) => void;
        /**
          * Wether this option is selected.
         */
        "selected"?: boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode"?: 'border' | 'growing';
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked"?: boolean;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: CustomEvent<SwitchChangeEventDetail>) => void;
    }
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header"?: string;
        "itemKey"?: any;
        /**
          * Do not use, meant for internal use only.
          * @inner 
          * @ignore
         */
        "onTabLoaded"?: (event: CustomEvent<void>) => void;
    }
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align"?: WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter"?: boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly"?: boolean;
        /**
          * Emitted when the selected tab change.
         */
        "onTabChange"?: (event: CustomEvent<WcsTabChangeEvent>) => void;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex"?: number;
        "selectedKey"?: any;
    }
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow"?: boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize"?: string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input value has changed.
         */
        "onWcsChange"?: (event: CustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: CustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: CustomEvent<KeyboardEvent>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    interface WcsTooltip {
        /**
          * The **id** of the element the tooltip's going to describe.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for"?: string;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position"?: WcsTooltipPosition;
    }
    interface IntrinsicElements {
        "wcs-action-bar": WcsActionBar;
        "wcs-app": WcsApp;
        "wcs-badge": WcsBadge;
        "wcs-button": WcsButton;
        "wcs-card": WcsCard;
        "wcs-card-body": WcsCardBody;
        "wcs-checkbox": WcsCheckbox;
        "wcs-com-nav": WcsComNav;
        "wcs-com-nav-category": WcsComNavCategory;
        "wcs-com-nav-submenu": WcsComNavSubmenu;
        "wcs-divider": WcsDivider;
        "wcs-dropdown": WcsDropdown;
        "wcs-dropdown-item": WcsDropdownItem;
        "wcs-editable-field": WcsEditableField;
        "wcs-error": WcsError;
        "wcs-field": WcsField;
        "wcs-field-content": WcsFieldContent;
        "wcs-field-label": WcsFieldLabel;
        "wcs-footer": WcsFooter;
        "wcs-form-field": WcsFormField;
        "wcs-galactic": WcsGalactic;
        "wcs-galactic-menu": WcsGalacticMenu;
        "wcs-grid": WcsGrid;
        "wcs-grid-column": WcsGridColumn;
        "wcs-grid-custom-cell": WcsGridCustomCell;
        "wcs-grid-pagination": WcsGridPagination;
        "wcs-header": WcsHeader;
        "wcs-hint": WcsHint;
        "wcs-horizontal-stepper": WcsHorizontalStepper;
        "wcs-icon": WcsIcon;
        "wcs-input": WcsInput;
        "wcs-label": WcsLabel;
        "wcs-list-item": WcsListItem;
        "wcs-list-item-properties": WcsListItemProperties;
        "wcs-list-item-property": WcsListItemProperty;
        "wcs-mat-icon": WcsMatIcon;
        "wcs-modal": WcsModal;
        "wcs-nav": WcsNav;
        "wcs-nav-item": WcsNavItem;
        "wcs-progress-bar": WcsProgressBar;
        "wcs-progress-radial": WcsProgressRadial;
        "wcs-radio": WcsRadio;
        "wcs-radio-group": WcsRadioGroup;
        "wcs-select": WcsSelect;
        "wcs-select-option": WcsSelectOption;
        "wcs-spinner": WcsSpinner;
        "wcs-switch": WcsSwitch;
        "wcs-tab": WcsTab;
        "wcs-tabs": WcsTabs;
        "wcs-textarea": WcsTextarea;
        "wcs-tooltip": WcsTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wcs-action-bar": LocalJSX.WcsActionBar & JSXBase.HTMLAttributes<HTMLWcsActionBarElement>;
            "wcs-app": LocalJSX.WcsApp & JSXBase.HTMLAttributes<HTMLWcsAppElement>;
            "wcs-badge": LocalJSX.WcsBadge & JSXBase.HTMLAttributes<HTMLWcsBadgeElement>;
            "wcs-button": LocalJSX.WcsButton & JSXBase.HTMLAttributes<HTMLWcsButtonElement>;
            "wcs-card": LocalJSX.WcsCard & JSXBase.HTMLAttributes<HTMLWcsCardElement>;
            "wcs-card-body": LocalJSX.WcsCardBody & JSXBase.HTMLAttributes<HTMLWcsCardBodyElement>;
            "wcs-checkbox": LocalJSX.WcsCheckbox & JSXBase.HTMLAttributes<HTMLWcsCheckboxElement>;
            "wcs-com-nav": LocalJSX.WcsComNav & JSXBase.HTMLAttributes<HTMLWcsComNavElement>;
            "wcs-com-nav-category": LocalJSX.WcsComNavCategory & JSXBase.HTMLAttributes<HTMLWcsComNavCategoryElement>;
            "wcs-com-nav-submenu": LocalJSX.WcsComNavSubmenu & JSXBase.HTMLAttributes<HTMLWcsComNavSubmenuElement>;
            "wcs-divider": LocalJSX.WcsDivider & JSXBase.HTMLAttributes<HTMLWcsDividerElement>;
            "wcs-dropdown": LocalJSX.WcsDropdown & JSXBase.HTMLAttributes<HTMLWcsDropdownElement>;
            "wcs-dropdown-item": LocalJSX.WcsDropdownItem & JSXBase.HTMLAttributes<HTMLWcsDropdownItemElement>;
            "wcs-editable-field": LocalJSX.WcsEditableField & JSXBase.HTMLAttributes<HTMLWcsEditableFieldElement>;
            "wcs-error": LocalJSX.WcsError & JSXBase.HTMLAttributes<HTMLWcsErrorElement>;
            "wcs-field": LocalJSX.WcsField & JSXBase.HTMLAttributes<HTMLWcsFieldElement>;
            "wcs-field-content": LocalJSX.WcsFieldContent & JSXBase.HTMLAttributes<HTMLWcsFieldContentElement>;
            "wcs-field-label": LocalJSX.WcsFieldLabel & JSXBase.HTMLAttributes<HTMLWcsFieldLabelElement>;
            "wcs-footer": LocalJSX.WcsFooter & JSXBase.HTMLAttributes<HTMLWcsFooterElement>;
            "wcs-form-field": LocalJSX.WcsFormField & JSXBase.HTMLAttributes<HTMLWcsFormFieldElement>;
            "wcs-galactic": LocalJSX.WcsGalactic & JSXBase.HTMLAttributes<HTMLWcsGalacticElement>;
            "wcs-galactic-menu": LocalJSX.WcsGalacticMenu & JSXBase.HTMLAttributes<HTMLWcsGalacticMenuElement>;
            "wcs-grid": LocalJSX.WcsGrid & JSXBase.HTMLAttributes<HTMLWcsGridElement>;
            "wcs-grid-column": LocalJSX.WcsGridColumn & JSXBase.HTMLAttributes<HTMLWcsGridColumnElement>;
            "wcs-grid-custom-cell": LocalJSX.WcsGridCustomCell & JSXBase.HTMLAttributes<HTMLWcsGridCustomCellElement>;
            "wcs-grid-pagination": LocalJSX.WcsGridPagination & JSXBase.HTMLAttributes<HTMLWcsGridPaginationElement>;
            "wcs-header": LocalJSX.WcsHeader & JSXBase.HTMLAttributes<HTMLWcsHeaderElement>;
            "wcs-hint": LocalJSX.WcsHint & JSXBase.HTMLAttributes<HTMLWcsHintElement>;
            "wcs-horizontal-stepper": LocalJSX.WcsHorizontalStepper & JSXBase.HTMLAttributes<HTMLWcsHorizontalStepperElement>;
            "wcs-icon": LocalJSX.WcsIcon & JSXBase.HTMLAttributes<HTMLWcsIconElement>;
            "wcs-input": LocalJSX.WcsInput & JSXBase.HTMLAttributes<HTMLWcsInputElement>;
            "wcs-label": LocalJSX.WcsLabel & JSXBase.HTMLAttributes<HTMLWcsLabelElement>;
            "wcs-list-item": LocalJSX.WcsListItem & JSXBase.HTMLAttributes<HTMLWcsListItemElement>;
            "wcs-list-item-properties": LocalJSX.WcsListItemProperties & JSXBase.HTMLAttributes<HTMLWcsListItemPropertiesElement>;
            "wcs-list-item-property": LocalJSX.WcsListItemProperty & JSXBase.HTMLAttributes<HTMLWcsListItemPropertyElement>;
            "wcs-mat-icon": LocalJSX.WcsMatIcon & JSXBase.HTMLAttributes<HTMLWcsMatIconElement>;
            "wcs-modal": LocalJSX.WcsModal & JSXBase.HTMLAttributes<HTMLWcsModalElement>;
            "wcs-nav": LocalJSX.WcsNav & JSXBase.HTMLAttributes<HTMLWcsNavElement>;
            "wcs-nav-item": LocalJSX.WcsNavItem & JSXBase.HTMLAttributes<HTMLWcsNavItemElement>;
            "wcs-progress-bar": LocalJSX.WcsProgressBar & JSXBase.HTMLAttributes<HTMLWcsProgressBarElement>;
            "wcs-progress-radial": LocalJSX.WcsProgressRadial & JSXBase.HTMLAttributes<HTMLWcsProgressRadialElement>;
            "wcs-radio": LocalJSX.WcsRadio & JSXBase.HTMLAttributes<HTMLWcsRadioElement>;
            "wcs-radio-group": LocalJSX.WcsRadioGroup & JSXBase.HTMLAttributes<HTMLWcsRadioGroupElement>;
            "wcs-select": LocalJSX.WcsSelect & JSXBase.HTMLAttributes<HTMLWcsSelectElement>;
            "wcs-select-option": LocalJSX.WcsSelectOption & JSXBase.HTMLAttributes<HTMLWcsSelectOptionElement>;
            "wcs-spinner": LocalJSX.WcsSpinner & JSXBase.HTMLAttributes<HTMLWcsSpinnerElement>;
            "wcs-switch": LocalJSX.WcsSwitch & JSXBase.HTMLAttributes<HTMLWcsSwitchElement>;
            "wcs-tab": LocalJSX.WcsTab & JSXBase.HTMLAttributes<HTMLWcsTabElement>;
            "wcs-tabs": LocalJSX.WcsTabs & JSXBase.HTMLAttributes<HTMLWcsTabsElement>;
            "wcs-textarea": LocalJSX.WcsTextarea & JSXBase.HTMLAttributes<HTMLWcsTextareaElement>;
            "wcs-tooltip": LocalJSX.WcsTooltip & JSXBase.HTMLAttributes<HTMLWcsTooltipElement>;
        }
    }
}
