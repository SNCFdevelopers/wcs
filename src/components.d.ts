/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BadgeColor, BadgeShape } from "./components/badge/badge-interface";
import { WcsButtonMode, WcsButtonShape, WcsButtonSize, WcsButtonType } from "./components/button/button-interface";
import { CardMode } from "./components/card/card-interface";
import { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
import { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
import { CounterChangeEventDetail, WcsCounterSize } from "./components/counter/counter-interface";
import { WcsDropdownPlacement } from "./components/dropdown/dropdown-interface";
import { EditableComponentUpdateEvent, EditableFieldType, FormatFn, ValidateFn, WcsEditableFieldSize } from "./components/editable-field/editable-field-interface";
import { WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridRowSelectedEventDetails, WcsGridSelectionConfig, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
import { HorizontalStepClickEvent, HorizontalStepConfig, HorizontalStepperMode } from "./components/horizontal-stepper/horizontal-stepper-interface";
import { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes, WcsInputSize } from "./components/input/input-interface";
import { MaterialIconFamily, MaterialIconSize } from "./components/mat-icon/mat-icon-interface";
import { ModalSize } from "./components/modal/modal-interface";
import { WcsNativeSelectSize } from "./components/native-select/native-select.component";
import { RadioGroupChangeEventDetail, RadioGroupMode } from "./components/radio-group/radio-group-interface";
import { RadioChosedEvent } from "./components/radio/radio-interface";
import { SelectChangeEventDetail, WcsSelectSize } from "./components/select/select-interface";
import { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
import { WcsSkeletonAnimation } from "./components/skeleton/skeleton-interface";
import { CssTypes } from "./shared-types";
import { WcsSpinnerMode } from "./components/spinner/spinner-interface";
import { SwitchChangeEventDetail, SwitchLabelAlignment } from "./components/switch/switch-interface";
import { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
import { TextareaChangeEventDetail } from "./components/textarea/textarea-interface";
import { WcsTooltipAppendTo, WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export { BadgeColor, BadgeShape } from "./components/badge/badge-interface";
export { WcsButtonMode, WcsButtonShape, WcsButtonSize, WcsButtonType } from "./components/button/button-interface";
export { CardMode } from "./components/card/card-interface";
export { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
export { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
export { CounterChangeEventDetail, WcsCounterSize } from "./components/counter/counter-interface";
export { WcsDropdownPlacement } from "./components/dropdown/dropdown-interface";
export { EditableComponentUpdateEvent, EditableFieldType, FormatFn, ValidateFn, WcsEditableFieldSize } from "./components/editable-field/editable-field-interface";
export { WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridRowSelectedEventDetails, WcsGridSelectionConfig, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
export { HorizontalStepClickEvent, HorizontalStepConfig, HorizontalStepperMode } from "./components/horizontal-stepper/horizontal-stepper-interface";
export { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes, WcsInputSize } from "./components/input/input-interface";
export { MaterialIconFamily, MaterialIconSize } from "./components/mat-icon/mat-icon-interface";
export { ModalSize } from "./components/modal/modal-interface";
export { WcsNativeSelectSize } from "./components/native-select/native-select.component";
export { RadioGroupChangeEventDetail, RadioGroupMode } from "./components/radio-group/radio-group-interface";
export { RadioChosedEvent } from "./components/radio/radio-interface";
export { SelectChangeEventDetail, WcsSelectSize } from "./components/select/select-interface";
export { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
export { WcsSkeletonAnimation } from "./components/skeleton/skeleton-interface";
export { CssTypes } from "./shared-types";
export { WcsSpinnerMode } from "./components/spinner/spinner-interface";
export { SwitchChangeEventDetail, SwitchLabelAlignment } from "./components/switch/switch-interface";
export { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
export { TextareaChangeEventDetail } from "./components/textarea/textarea-interface";
export { WcsTooltipAppendTo, WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export namespace Components {
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight": boolean;
    }
    interface WcsAccordionContent {
    }
    interface WcsAccordionHeader {
    }
    interface WcsAccordionPanel {
        "close": () => Promise<void>;
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight": boolean;
        "open": boolean;
    }
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter": boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color": BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape": BadgeShape;
    }
    /**
     * Button component, can also be a link when specifying href.
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface WcsButton {
        /**
          * Specify whether the button is disabled or not.
         */
        "disabled": boolean;
        /**
          * Set a URL to point to.<br/> If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading": boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode": WcsButtonMode;
        /**
          * Specify whether the button should have a ripple effect or not.
         */
        "ripple": boolean;
        /**
          * Specify the shape of the button.
         */
        "shape": WcsButtonShape;
        /**
          * Specify the size of the button.
         */
        "size": WcsButtonSize;
        /**
          * Specifies where to open the linked document when using href (see prop above)<br/> Default '_self' will open the linked document in the same frame as it was clicked
         */
        "target"?: '_blank' | '_self';
        /**
          * Specify the button type.
         */
        "type": WcsButtonType;
    }
    interface WcsCard {
        "mode": CardMode;
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled": boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment": CheckboxLabelAlignment;
        "name": string;
    }
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName": string;
    }
    interface WcsComNavCategory {
        /**
          * Close the category
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the category
         */
        "open": () => Promise<void>;
    }
    interface WcsComNavSubmenu {
        /**
          * Close the menu
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the menu
         */
        "open": () => Promise<void>;
        "panelDescription": string;
        "panelTitle": string;
    }
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface WcsCounter {
        /**
          * The label of the counter.<br/> e.g. Number of passengers, train carriages, railroad tracks...
         */
        "label": string;
        /**
          * The maximum value of the counter. If the value of the max attribute isn't set, then the element has no maximum value.
         */
        "max"?: number;
        /**
          * The minimum value of the counter. If the value of the min attribute isn't set, then the element has no minimum value.
         */
        "min"?: number;
        /**
          * Specify the size (height) of the counter.
         */
        "size": WcsCounterSize;
        /**
          * Defines by how much the counter will be incremented or decremented.
         */
        "step": number;
        /**
          * Allow to change currentValue programmatically
         */
        "value"?: number;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled": boolean;
        /**
          * Dropdown's button mode
         */
        "mode": WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow": boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement": WcsDropdownPlacement;
        /**
          * Dropdown's button shape
         */
        "shape": WcsButtonShape;
    }
    interface WcsDropdownDivider {
    }
    interface WcsDropdownHeader {
    }
    interface WcsDropdownItem {
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg": string;
        /**
          * Function used to format the value
         */
        "formatFn": FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * Specify whether the field is editable or not
         */
        "readonly": boolean;
        /**
          * Specify the size (height) of the editable field.
         */
        "size": WcsEditableFieldSize;
        /**
          * Specifies which component is used for editing
         */
        "type": EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn": ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value": any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    /**
     * TODO:
     * - [ ] Suffix button style
     */
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError": boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text": string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text": string;
    }
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface WcsGrid {
        /**
          * Contains the data to display in the table from a js object
         */
        "data": any[];
        /**
          * Flag to display a spinner during data loading
         */
        "loading": boolean;
        /**
          * Name of the object's key that will be used to display the cells whose `keyValue` attribute matches to the object's value for this key.
         */
        "rowIdPath": string;
        /**
          * Set the selected items (rows)
         */
        "selectedItems": any | any[];
        /**
          * Used to manage grid's row selection.   "none": no row can be selected.   "multiple": several rows can be selected.   "single": one row only can be selected.
         */
        "selectionConfig": WcsGridSelectionConfig;
        /**
          * Manage sort and pagination with a backend server when set to `true`
         */
        "serverMode": boolean;
        /**
          * Automatically set by the component to reference the wcs-grid-pagination HTML element by its id.
         */
        "wcsGridPaginationId": string;
    }
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface WcsGridColumn {
        /**
          * Set to true if using a `wcs-custom-cell` linked to it.
         */
        "customCells": boolean;
        /**
          * Customizable formatter function to render the cell differently.
         */
        "formatter": WcsCellFormatter;
        /**
          * Flag to hide the column.
         */
        "hidden": boolean;
        /**
          * The name of the column displayed on the table (e.g: First Name, Last Name, Email, ...)
         */
        "name": string;
        /**
          * Represents the name of the field from the `data` object (e.g: first_name, last_name, email, ...)
         */
        "path": string;
        /**
          * Make the column sortable.
         */
        "sort": boolean;
        /**
          * Customizable sort function to change the comparison of values.
         */
        "sortFn": WcsSortFn;
        /**
          * Defines if the column sort is ascending or descending.   `none` = the column is not sorted.
         */
        "sortOrder": WcsSortOrder;
        /**
          * Set the column `<th>` element width.
         */
        "width": string;
    }
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId": string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId": any;
    }
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface WcsGridPagination {
        /**
          * Set the available page sizes in the pagination dropdown on the left.
         */
        "availablePageSizes": number[];
        /**
          * The current page of the pagination. First page starts at index 0.
         */
        "currentPage": number;
        /**
          * Total elements in the grid.   - **Grid in `Server mode`** : You have to set `itemsCount` = your total data length.   - **Grid not in Server mode** : Do not set it manually : itemsCount is set and updated every pagination refresh.
         */
        "itemsCount": number;
        /**
          * Max number of pages.   - **Grid in `Server mode`** : You have to set `pageCount` = `itemsCount` divided by `pageSize`.   - **Grid not in Server mode** : Do not set it manually : pageCount is set and updated every pagination refresh.
         */
        "pageCount": number;
        /**
          * Maximum number of elements shown per page.   Default is the first value of `availablePageSizes`.
         */
        "pageSize": number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        /**
          * Whether the component should display the small version of the hint
         */
        "small": boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete": boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep": number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode": HorizontalStepperMode;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        /**
          * steps to display
         */
        "steps": HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon": string;
        "size": 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    /**
     * Mainly inspired from Ionic Input Component
     */
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Sets blur on the native `input` in `wcs-input`. Use this method instead of the global `input.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * @deprecated use the native focus method instead  Sets focus on the native `input` in `wcs-input`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Specify the size (height) of the input.
         */
        "size": WcsInputSize;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel": string;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required": boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated": boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family": MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon": string;
        /**
          * Size of the icon
         */
        "size": MaterialIconSize;
    }
    interface WcsModal {
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions": boolean;
        /**
          * Displays the modal
         */
        "show": boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton": boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size": ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop": boolean;
    }
    /**
     * The `wcs-native-select` component is designed to accept a native <select> element as a slotted child. This choice
     * allows developers to bind the <select> element using the framework of their choice, without the need to re-expose all the
     * properties of the <select> and <option> elements in this component.
     * The component wraps the native <select> element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * Example usage:
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     */
    interface WcsNativeSelect {
        /**
          * The `size` property controls the size of the slotted `select` element by adjusting its padding. There are two possible size options: - 'm': medium size - 'l': large size  The default value is 'm'.
         */
        "size": WcsNativeSelectSize;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href": string;
        /**
          * This attribute specify the text of the item.
         */
        "text": string;
    }
    /**
     * Component displaying progress as a bar.
     */
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel": boolean;
        /**
          * Whether the component display the small version
         */
        "small": boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value": number;
    }
    interface WcsProgressRadial {
        "showLabel": boolean;
        "size": number;
        "value": number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked": boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled": boolean;
        "label": string;
        "mode": RadioGroupMode;
        "value": any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode": RadioGroupMode;
        "name": any;
        "value": any | any[] | undefined | null;
    }
    /**
     * Select component, use in conjuction with wcs-select-option.
     * @example ```hmtl
     * <wcs-select>
     * <wcs-select-option value="1">One</wcs-select-option>
     * </wcs-select>```
     */
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips": boolean;
        /**
          * Close the component.
         */
        "close": () => Promise<void>;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled": boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Open the component.
         */
        "open": () => Promise<void>;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * Specify the size (height) of the select.
         */
        "size": WcsSelectSize;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    /**
     * Select option component, use in conjunction with wcs-select.
     */
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled": boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple": boolean;
        /**
          * Wether this option is selected.
         */
        "selected": boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface WcsSkeletonCircle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the radius of the circle in px
         */
        "radius": number;
    }
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface WcsSkeletonRectangle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the height of the skeleton (can be any valid CSS value)
         */
        "height": CssTypes.Height;
        /**
          * Adds a border radius on the skeleton if true
         */
        "rounded": boolean;
        /**
          * Specifies the width of the skeleton (can be any valid CSS value)
         */
        "width": CssTypes.Width;
    }
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface WcsSkeletonText {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the line height of the text skeleton
         */
        "height": 'h1' | 'h2' | 'h3' | 'caption' | 'body';
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode": WcsSpinnerMode;
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled": boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment": SwitchLabelAlignment;
        "name": string;
    }
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header": string;
        "itemKey": any;
    }
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     */
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align": WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter": boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly": boolean;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex": number;
        "selectedKey": any;
    }
    /**
     * Mainly inspired from Ionic Textarea Component
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     */
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow": boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize": string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit": boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * This method make the textarea automatically adopt the size of the content without a scroll bar
         */
        "fitContent": () => Promise<void>;
        /**
          * Returns the native `<textarea>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Indicates how the textarea should be resizable. Possible values 'both' | 'none' | 'vertical' | 'horizontal'
         */
        "resize"?: 'both' | 'none' | 'vertical' | 'horizontal';
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * Sets blur on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Sets focus on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state": 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     */
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo": WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content": string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay": number | [number, number];
        /**
          * Temporarily prevent the tooltip from showing or hiding
         */
        "disable": () => Promise<void>;
        /**
          * Duration in ms of the transition animation.
         */
        "duration": number | [number, number];
        /**
          * Re-enable a disabled tooltip
         */
        "enable": () => Promise<void>;
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for": string;
        /**
          * Programmatically hide the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive": boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.
         */
        "maxWidth": string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position": WcsTooltipPosition;
        /**
          * Programmatically show the tooltip
         */
        "show": () => Promise<void>;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme": string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger": string;
    }
}
export interface WcsAccordionPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsAccordionPanelElement;
}
export interface WcsCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsCheckboxElement;
}
export interface WcsComNavCategoryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavCategoryElement;
}
export interface WcsComNavSubmenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavSubmenuElement;
}
export interface WcsCounterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsCounterElement;
}
export interface WcsDropdownItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsDropdownItemElement;
}
export interface WcsEditableFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsEditableFieldElement;
}
export interface WcsGridCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridElement;
}
export interface WcsGridColumnCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridColumnElement;
}
export interface WcsGridPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridPaginationElement;
}
export interface WcsHorizontalStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsHorizontalStepperElement;
}
export interface WcsInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsInputElement;
}
export interface WcsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsModalElement;
}
export interface WcsRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioElement;
}
export interface WcsRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioGroupElement;
}
export interface WcsSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectElement;
}
export interface WcsSelectOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectOptionElement;
}
export interface WcsSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSwitchElement;
}
export interface WcsTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabElement;
}
export interface WcsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabsElement;
}
export interface WcsTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTextareaElement;
}
declare global {
    interface HTMLWcsAccordionElement extends Components.WcsAccordion, HTMLStencilElement {
    }
    var HTMLWcsAccordionElement: {
        prototype: HTMLWcsAccordionElement;
        new (): HTMLWcsAccordionElement;
    };
    interface HTMLWcsAccordionContentElement extends Components.WcsAccordionContent, HTMLStencilElement {
    }
    var HTMLWcsAccordionContentElement: {
        prototype: HTMLWcsAccordionContentElement;
        new (): HTMLWcsAccordionContentElement;
    };
    interface HTMLWcsAccordionHeaderElement extends Components.WcsAccordionHeader, HTMLStencilElement {
    }
    var HTMLWcsAccordionHeaderElement: {
        prototype: HTMLWcsAccordionHeaderElement;
        new (): HTMLWcsAccordionHeaderElement;
    };
    interface HTMLWcsAccordionPanelElement extends Components.WcsAccordionPanel, HTMLStencilElement {
    }
    var HTMLWcsAccordionPanelElement: {
        prototype: HTMLWcsAccordionPanelElement;
        new (): HTMLWcsAccordionPanelElement;
    };
    interface HTMLWcsActionBarElement extends Components.WcsActionBar, HTMLStencilElement {
    }
    var HTMLWcsActionBarElement: {
        prototype: HTMLWcsActionBarElement;
        new (): HTMLWcsActionBarElement;
    };
    interface HTMLWcsAppElement extends Components.WcsApp, HTMLStencilElement {
    }
    var HTMLWcsAppElement: {
        prototype: HTMLWcsAppElement;
        new (): HTMLWcsAppElement;
    };
    interface HTMLWcsBadgeElement extends Components.WcsBadge, HTMLStencilElement {
    }
    var HTMLWcsBadgeElement: {
        prototype: HTMLWcsBadgeElement;
        new (): HTMLWcsBadgeElement;
    };
    /**
     * Button component, can also be a link when specifying href.
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface HTMLWcsButtonElement extends Components.WcsButton, HTMLStencilElement {
    }
    var HTMLWcsButtonElement: {
        prototype: HTMLWcsButtonElement;
        new (): HTMLWcsButtonElement;
    };
    interface HTMLWcsCardElement extends Components.WcsCard, HTMLStencilElement {
    }
    var HTMLWcsCardElement: {
        prototype: HTMLWcsCardElement;
        new (): HTMLWcsCardElement;
    };
    interface HTMLWcsCardBodyElement extends Components.WcsCardBody, HTMLStencilElement {
    }
    var HTMLWcsCardBodyElement: {
        prototype: HTMLWcsCardBodyElement;
        new (): HTMLWcsCardBodyElement;
    };
    interface HTMLWcsCheckboxElement extends Components.WcsCheckbox, HTMLStencilElement {
    }
    var HTMLWcsCheckboxElement: {
        prototype: HTMLWcsCheckboxElement;
        new (): HTMLWcsCheckboxElement;
    };
    interface HTMLWcsComNavElement extends Components.WcsComNav, HTMLStencilElement {
    }
    var HTMLWcsComNavElement: {
        prototype: HTMLWcsComNavElement;
        new (): HTMLWcsComNavElement;
    };
    interface HTMLWcsComNavCategoryElement extends Components.WcsComNavCategory, HTMLStencilElement {
    }
    var HTMLWcsComNavCategoryElement: {
        prototype: HTMLWcsComNavCategoryElement;
        new (): HTMLWcsComNavCategoryElement;
    };
    interface HTMLWcsComNavSubmenuElement extends Components.WcsComNavSubmenu, HTMLStencilElement {
    }
    var HTMLWcsComNavSubmenuElement: {
        prototype: HTMLWcsComNavSubmenuElement;
        new (): HTMLWcsComNavSubmenuElement;
    };
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface HTMLWcsCounterElement extends Components.WcsCounter, HTMLStencilElement {
    }
    var HTMLWcsCounterElement: {
        prototype: HTMLWcsCounterElement;
        new (): HTMLWcsCounterElement;
    };
    interface HTMLWcsDividerElement extends Components.WcsDivider, HTMLStencilElement {
    }
    var HTMLWcsDividerElement: {
        prototype: HTMLWcsDividerElement;
        new (): HTMLWcsDividerElement;
    };
    interface HTMLWcsDropdownElement extends Components.WcsDropdown, HTMLStencilElement {
    }
    var HTMLWcsDropdownElement: {
        prototype: HTMLWcsDropdownElement;
        new (): HTMLWcsDropdownElement;
    };
    interface HTMLWcsDropdownDividerElement extends Components.WcsDropdownDivider, HTMLStencilElement {
    }
    var HTMLWcsDropdownDividerElement: {
        prototype: HTMLWcsDropdownDividerElement;
        new (): HTMLWcsDropdownDividerElement;
    };
    interface HTMLWcsDropdownHeaderElement extends Components.WcsDropdownHeader, HTMLStencilElement {
    }
    var HTMLWcsDropdownHeaderElement: {
        prototype: HTMLWcsDropdownHeaderElement;
        new (): HTMLWcsDropdownHeaderElement;
    };
    interface HTMLWcsDropdownItemElement extends Components.WcsDropdownItem, HTMLStencilElement {
    }
    var HTMLWcsDropdownItemElement: {
        prototype: HTMLWcsDropdownItemElement;
        new (): HTMLWcsDropdownItemElement;
    };
    interface HTMLWcsEditableFieldElement extends Components.WcsEditableField, HTMLStencilElement {
    }
    var HTMLWcsEditableFieldElement: {
        prototype: HTMLWcsEditableFieldElement;
        new (): HTMLWcsEditableFieldElement;
    };
    interface HTMLWcsErrorElement extends Components.WcsError, HTMLStencilElement {
    }
    var HTMLWcsErrorElement: {
        prototype: HTMLWcsErrorElement;
        new (): HTMLWcsErrorElement;
    };
    interface HTMLWcsFieldElement extends Components.WcsField, HTMLStencilElement {
    }
    var HTMLWcsFieldElement: {
        prototype: HTMLWcsFieldElement;
        new (): HTMLWcsFieldElement;
    };
    interface HTMLWcsFieldContentElement extends Components.WcsFieldContent, HTMLStencilElement {
    }
    var HTMLWcsFieldContentElement: {
        prototype: HTMLWcsFieldContentElement;
        new (): HTMLWcsFieldContentElement;
    };
    interface HTMLWcsFieldLabelElement extends Components.WcsFieldLabel, HTMLStencilElement {
    }
    var HTMLWcsFieldLabelElement: {
        prototype: HTMLWcsFieldLabelElement;
        new (): HTMLWcsFieldLabelElement;
    };
    interface HTMLWcsFooterElement extends Components.WcsFooter, HTMLStencilElement {
    }
    var HTMLWcsFooterElement: {
        prototype: HTMLWcsFooterElement;
        new (): HTMLWcsFooterElement;
    };
    /**
     * TODO:
     * - [ ] Suffix button style
     */
    interface HTMLWcsFormFieldElement extends Components.WcsFormField, HTMLStencilElement {
    }
    var HTMLWcsFormFieldElement: {
        prototype: HTMLWcsFormFieldElement;
        new (): HTMLWcsFormFieldElement;
    };
    interface HTMLWcsGalacticElement extends Components.WcsGalactic, HTMLStencilElement {
    }
    var HTMLWcsGalacticElement: {
        prototype: HTMLWcsGalacticElement;
        new (): HTMLWcsGalacticElement;
    };
    interface HTMLWcsGalacticMenuElement extends Components.WcsGalacticMenu, HTMLStencilElement {
    }
    var HTMLWcsGalacticMenuElement: {
        prototype: HTMLWcsGalacticMenuElement;
        new (): HTMLWcsGalacticMenuElement;
    };
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface HTMLWcsGridElement extends Components.WcsGrid, HTMLStencilElement {
    }
    var HTMLWcsGridElement: {
        prototype: HTMLWcsGridElement;
        new (): HTMLWcsGridElement;
    };
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface HTMLWcsGridColumnElement extends Components.WcsGridColumn, HTMLStencilElement {
    }
    var HTMLWcsGridColumnElement: {
        prototype: HTMLWcsGridColumnElement;
        new (): HTMLWcsGridColumnElement;
    };
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface HTMLWcsGridCustomCellElement extends Components.WcsGridCustomCell, HTMLStencilElement {
    }
    var HTMLWcsGridCustomCellElement: {
        prototype: HTMLWcsGridCustomCellElement;
        new (): HTMLWcsGridCustomCellElement;
    };
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface HTMLWcsGridPaginationElement extends Components.WcsGridPagination, HTMLStencilElement {
    }
    var HTMLWcsGridPaginationElement: {
        prototype: HTMLWcsGridPaginationElement;
        new (): HTMLWcsGridPaginationElement;
    };
    interface HTMLWcsHeaderElement extends Components.WcsHeader, HTMLStencilElement {
    }
    var HTMLWcsHeaderElement: {
        prototype: HTMLWcsHeaderElement;
        new (): HTMLWcsHeaderElement;
    };
    interface HTMLWcsHintElement extends Components.WcsHint, HTMLStencilElement {
    }
    var HTMLWcsHintElement: {
        prototype: HTMLWcsHintElement;
        new (): HTMLWcsHintElement;
    };
    interface HTMLWcsHorizontalStepperElement extends Components.WcsHorizontalStepper, HTMLStencilElement {
    }
    var HTMLWcsHorizontalStepperElement: {
        prototype: HTMLWcsHorizontalStepperElement;
        new (): HTMLWcsHorizontalStepperElement;
    };
    interface HTMLWcsIconElement extends Components.WcsIcon, HTMLStencilElement {
    }
    var HTMLWcsIconElement: {
        prototype: HTMLWcsIconElement;
        new (): HTMLWcsIconElement;
    };
    /**
     * Mainly inspired from Ionic Input Component
     */
    interface HTMLWcsInputElement extends Components.WcsInput, HTMLStencilElement {
    }
    var HTMLWcsInputElement: {
        prototype: HTMLWcsInputElement;
        new (): HTMLWcsInputElement;
    };
    interface HTMLWcsLabelElement extends Components.WcsLabel, HTMLStencilElement {
    }
    var HTMLWcsLabelElement: {
        prototype: HTMLWcsLabelElement;
        new (): HTMLWcsLabelElement;
    };
    interface HTMLWcsListItemElement extends Components.WcsListItem, HTMLStencilElement {
    }
    var HTMLWcsListItemElement: {
        prototype: HTMLWcsListItemElement;
        new (): HTMLWcsListItemElement;
    };
    interface HTMLWcsListItemPropertiesElement extends Components.WcsListItemProperties, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertiesElement: {
        prototype: HTMLWcsListItemPropertiesElement;
        new (): HTMLWcsListItemPropertiesElement;
    };
    interface HTMLWcsListItemPropertyElement extends Components.WcsListItemProperty, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertyElement: {
        prototype: HTMLWcsListItemPropertyElement;
        new (): HTMLWcsListItemPropertyElement;
    };
    interface HTMLWcsMatIconElement extends Components.WcsMatIcon, HTMLStencilElement {
    }
    var HTMLWcsMatIconElement: {
        prototype: HTMLWcsMatIconElement;
        new (): HTMLWcsMatIconElement;
    };
    interface HTMLWcsModalElement extends Components.WcsModal, HTMLStencilElement {
    }
    var HTMLWcsModalElement: {
        prototype: HTMLWcsModalElement;
        new (): HTMLWcsModalElement;
    };
    /**
     * The `wcs-native-select` component is designed to accept a native <select> element as a slotted child. This choice
     * allows developers to bind the <select> element using the framework of their choice, without the need to re-expose all the
     * properties of the <select> and <option> elements in this component.
     * The component wraps the native <select> element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * Example usage:
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     */
    interface HTMLWcsNativeSelectElement extends Components.WcsNativeSelect, HTMLStencilElement {
    }
    var HTMLWcsNativeSelectElement: {
        prototype: HTMLWcsNativeSelectElement;
        new (): HTMLWcsNativeSelectElement;
    };
    interface HTMLWcsNavElement extends Components.WcsNav, HTMLStencilElement {
    }
    var HTMLWcsNavElement: {
        prototype: HTMLWcsNavElement;
        new (): HTMLWcsNavElement;
    };
    interface HTMLWcsNavItemElement extends Components.WcsNavItem, HTMLStencilElement {
    }
    var HTMLWcsNavItemElement: {
        prototype: HTMLWcsNavItemElement;
        new (): HTMLWcsNavItemElement;
    };
    /**
     * Component displaying progress as a bar.
     */
    interface HTMLWcsProgressBarElement extends Components.WcsProgressBar, HTMLStencilElement {
    }
    var HTMLWcsProgressBarElement: {
        prototype: HTMLWcsProgressBarElement;
        new (): HTMLWcsProgressBarElement;
    };
    interface HTMLWcsProgressRadialElement extends Components.WcsProgressRadial, HTMLStencilElement {
    }
    var HTMLWcsProgressRadialElement: {
        prototype: HTMLWcsProgressRadialElement;
        new (): HTMLWcsProgressRadialElement;
    };
    interface HTMLWcsRadioElement extends Components.WcsRadio, HTMLStencilElement {
    }
    var HTMLWcsRadioElement: {
        prototype: HTMLWcsRadioElement;
        new (): HTMLWcsRadioElement;
    };
    interface HTMLWcsRadioGroupElement extends Components.WcsRadioGroup, HTMLStencilElement {
    }
    var HTMLWcsRadioGroupElement: {
        prototype: HTMLWcsRadioGroupElement;
        new (): HTMLWcsRadioGroupElement;
    };
    /**
     * Select component, use in conjuction with wcs-select-option.
     * @example ```hmtl
     * <wcs-select>
     * <wcs-select-option value="1">One</wcs-select-option>
     * </wcs-select>```
     */
    interface HTMLWcsSelectElement extends Components.WcsSelect, HTMLStencilElement {
    }
    var HTMLWcsSelectElement: {
        prototype: HTMLWcsSelectElement;
        new (): HTMLWcsSelectElement;
    };
    /**
     * Select option component, use in conjunction with wcs-select.
     */
    interface HTMLWcsSelectOptionElement extends Components.WcsSelectOption, HTMLStencilElement {
    }
    var HTMLWcsSelectOptionElement: {
        prototype: HTMLWcsSelectOptionElement;
        new (): HTMLWcsSelectOptionElement;
    };
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface HTMLWcsSkeletonCircleElement extends Components.WcsSkeletonCircle, HTMLStencilElement {
    }
    var HTMLWcsSkeletonCircleElement: {
        prototype: HTMLWcsSkeletonCircleElement;
        new (): HTMLWcsSkeletonCircleElement;
    };
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface HTMLWcsSkeletonRectangleElement extends Components.WcsSkeletonRectangle, HTMLStencilElement {
    }
    var HTMLWcsSkeletonRectangleElement: {
        prototype: HTMLWcsSkeletonRectangleElement;
        new (): HTMLWcsSkeletonRectangleElement;
    };
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface HTMLWcsSkeletonTextElement extends Components.WcsSkeletonText, HTMLStencilElement {
    }
    var HTMLWcsSkeletonTextElement: {
        prototype: HTMLWcsSkeletonTextElement;
        new (): HTMLWcsSkeletonTextElement;
    };
    interface HTMLWcsSpinnerElement extends Components.WcsSpinner, HTMLStencilElement {
    }
    var HTMLWcsSpinnerElement: {
        prototype: HTMLWcsSpinnerElement;
        new (): HTMLWcsSpinnerElement;
    };
    interface HTMLWcsSwitchElement extends Components.WcsSwitch, HTMLStencilElement {
    }
    var HTMLWcsSwitchElement: {
        prototype: HTMLWcsSwitchElement;
        new (): HTMLWcsSwitchElement;
    };
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface HTMLWcsTabElement extends Components.WcsTab, HTMLStencilElement {
    }
    var HTMLWcsTabElement: {
        prototype: HTMLWcsTabElement;
        new (): HTMLWcsTabElement;
    };
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     */
    interface HTMLWcsTabsElement extends Components.WcsTabs, HTMLStencilElement {
    }
    var HTMLWcsTabsElement: {
        prototype: HTMLWcsTabsElement;
        new (): HTMLWcsTabsElement;
    };
    /**
     * Mainly inspired from Ionic Textarea Component
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     */
    interface HTMLWcsTextareaElement extends Components.WcsTextarea, HTMLStencilElement {
    }
    var HTMLWcsTextareaElement: {
        prototype: HTMLWcsTextareaElement;
        new (): HTMLWcsTextareaElement;
    };
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     */
    interface HTMLWcsTooltipElement extends Components.WcsTooltip, HTMLStencilElement {
    }
    var HTMLWcsTooltipElement: {
        prototype: HTMLWcsTooltipElement;
        new (): HTMLWcsTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "wcs-accordion": HTMLWcsAccordionElement;
        "wcs-accordion-content": HTMLWcsAccordionContentElement;
        "wcs-accordion-header": HTMLWcsAccordionHeaderElement;
        "wcs-accordion-panel": HTMLWcsAccordionPanelElement;
        "wcs-action-bar": HTMLWcsActionBarElement;
        "wcs-app": HTMLWcsAppElement;
        "wcs-badge": HTMLWcsBadgeElement;
        "wcs-button": HTMLWcsButtonElement;
        "wcs-card": HTMLWcsCardElement;
        "wcs-card-body": HTMLWcsCardBodyElement;
        "wcs-checkbox": HTMLWcsCheckboxElement;
        "wcs-com-nav": HTMLWcsComNavElement;
        "wcs-com-nav-category": HTMLWcsComNavCategoryElement;
        "wcs-com-nav-submenu": HTMLWcsComNavSubmenuElement;
        "wcs-counter": HTMLWcsCounterElement;
        "wcs-divider": HTMLWcsDividerElement;
        "wcs-dropdown": HTMLWcsDropdownElement;
        "wcs-dropdown-divider": HTMLWcsDropdownDividerElement;
        "wcs-dropdown-header": HTMLWcsDropdownHeaderElement;
        "wcs-dropdown-item": HTMLWcsDropdownItemElement;
        "wcs-editable-field": HTMLWcsEditableFieldElement;
        "wcs-error": HTMLWcsErrorElement;
        "wcs-field": HTMLWcsFieldElement;
        "wcs-field-content": HTMLWcsFieldContentElement;
        "wcs-field-label": HTMLWcsFieldLabelElement;
        "wcs-footer": HTMLWcsFooterElement;
        "wcs-form-field": HTMLWcsFormFieldElement;
        "wcs-galactic": HTMLWcsGalacticElement;
        "wcs-galactic-menu": HTMLWcsGalacticMenuElement;
        "wcs-grid": HTMLWcsGridElement;
        "wcs-grid-column": HTMLWcsGridColumnElement;
        "wcs-grid-custom-cell": HTMLWcsGridCustomCellElement;
        "wcs-grid-pagination": HTMLWcsGridPaginationElement;
        "wcs-header": HTMLWcsHeaderElement;
        "wcs-hint": HTMLWcsHintElement;
        "wcs-horizontal-stepper": HTMLWcsHorizontalStepperElement;
        "wcs-icon": HTMLWcsIconElement;
        "wcs-input": HTMLWcsInputElement;
        "wcs-label": HTMLWcsLabelElement;
        "wcs-list-item": HTMLWcsListItemElement;
        "wcs-list-item-properties": HTMLWcsListItemPropertiesElement;
        "wcs-list-item-property": HTMLWcsListItemPropertyElement;
        "wcs-mat-icon": HTMLWcsMatIconElement;
        "wcs-modal": HTMLWcsModalElement;
        "wcs-native-select": HTMLWcsNativeSelectElement;
        "wcs-nav": HTMLWcsNavElement;
        "wcs-nav-item": HTMLWcsNavItemElement;
        "wcs-progress-bar": HTMLWcsProgressBarElement;
        "wcs-progress-radial": HTMLWcsProgressRadialElement;
        "wcs-radio": HTMLWcsRadioElement;
        "wcs-radio-group": HTMLWcsRadioGroupElement;
        "wcs-select": HTMLWcsSelectElement;
        "wcs-select-option": HTMLWcsSelectOptionElement;
        "wcs-skeleton-circle": HTMLWcsSkeletonCircleElement;
        "wcs-skeleton-rectangle": HTMLWcsSkeletonRectangleElement;
        "wcs-skeleton-text": HTMLWcsSkeletonTextElement;
        "wcs-spinner": HTMLWcsSpinnerElement;
        "wcs-switch": HTMLWcsSwitchElement;
        "wcs-tab": HTMLWcsTabElement;
        "wcs-tabs": HTMLWcsTabsElement;
        "wcs-textarea": HTMLWcsTextareaElement;
        "wcs-tooltip": HTMLWcsTooltipElement;
    }
}
declare namespace LocalJSX {
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight"?: boolean;
    }
    interface WcsAccordionContent {
    }
    interface WcsAccordionHeader {
    }
    interface WcsAccordionPanel {
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight"?: boolean;
        "onWcsOpenChange"?: (event: WcsAccordionPanelCustomEvent<boolean>) => void;
        "open"?: boolean;
    }
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter"?: boolean;
    }
    interface WcsApp {
    }
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color"?: BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape"?: BadgeShape;
    }
    /**
     * Button component, can also be a link when specifying href.
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface WcsButton {
        /**
          * Specify whether the button is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Set a URL to point to.<br/> If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading"?: boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode"?: WcsButtonMode;
        /**
          * Specify whether the button should have a ripple effect or not.
         */
        "ripple"?: boolean;
        /**
          * Specify the shape of the button.
         */
        "shape"?: WcsButtonShape;
        /**
          * Specify the size of the button.
         */
        "size"?: WcsButtonSize;
        /**
          * Specifies where to open the linked document when using href (see prop above)<br/> Default '_self' will open the linked document in the same frame as it was clicked
         */
        "target"?: '_blank' | '_self';
        /**
          * Specify the button type.
         */
        "type"?: WcsButtonType;
    }
    interface WcsCard {
        "mode"?: CardMode;
    }
    interface WcsCardBody {
    }
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment"?: CheckboxLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
    }
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName"?: string;
    }
    interface WcsComNavCategory {
        "label"?: string;
        "onWcsCategoryItemClicked"?: (event: WcsComNavCategoryCustomEvent<UIEvent>) => void;
        "onWcsCategoryOpened"?: (event: WcsComNavCategoryCustomEvent<CategoryOpenedEventDetail>) => void;
    }
    interface WcsComNavSubmenu {
        "label"?: string;
        /**
          * Emitted when a user click on a final navigation action.  Used by the com-nav component to close the mobile menu overlay when a user click on a final action.
         */
        "onWcsClickOnFinalAction"?: (event: WcsComNavSubmenuCustomEvent<void>) => void;
        "onWcsSubmenuOpened"?: (event: WcsComNavSubmenuCustomEvent<MenuOpenedEventDetail>) => void;
        "panelDescription"?: string;
        "panelTitle"?: string;
    }
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface WcsCounter {
        /**
          * The label of the counter.<br/> e.g. Number of passengers, train carriages, railroad tracks...
         */
        "label": string;
        /**
          * The maximum value of the counter. If the value of the max attribute isn't set, then the element has no maximum value.
         */
        "max"?: number;
        /**
          * The minimum value of the counter. If the value of the min attribute isn't set, then the element has no minimum value.
         */
        "min"?: number;
        /**
          * Emitted when the counter loses focus.
         */
        "onWcsBlur"?: (event: WcsCounterCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value of the counter has changed.
         */
        "onWcsChange"?: (event: WcsCounterCustomEvent<CounterChangeEventDetail>) => void;
        /**
          * Specify the size (height) of the counter.
         */
        "size"?: WcsCounterSize;
        /**
          * Defines by how much the counter will be incremented or decremented.
         */
        "step"?: number;
        /**
          * Allow to change currentValue programmatically
         */
        "value"?: number;
    }
    interface WcsDivider {
    }
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled"?: boolean;
        /**
          * Dropdown's button mode
         */
        "mode"?: WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow"?: boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement"?: WcsDropdownPlacement;
        /**
          * Dropdown's button shape
         */
        "shape"?: WcsButtonShape;
    }
    interface WcsDropdownDivider {
    }
    interface WcsDropdownHeader {
    }
    interface WcsDropdownItem {
        "onWcsDropdownItemClick"?: (event: WcsDropdownItemCustomEvent<void>) => void;
    }
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg"?: string;
        /**
          * Function used to format the value
         */
        "formatFn"?: FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * event called at each (valid) update of the field.
         */
        "onWcsChange"?: (event: WcsEditableFieldCustomEvent<EditableComponentUpdateEvent>) => void;
        /**
          * Specify whether the field is editable or not
         */
        "readonly"?: boolean;
        /**
          * Specify the size (height) of the editable field.
         */
        "size"?: WcsEditableFieldSize;
        /**
          * Specifies which component is used for editing
         */
        "type"?: EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn"?: ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value"?: any;
    }
    interface WcsError {
    }
    interface WcsField {
    }
    interface WcsFieldContent {
    }
    interface WcsFieldLabel {
    }
    interface WcsFooter {
    }
    /**
     * TODO:
     * - [ ] Suffix button style
     */
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError"?: boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text"?: string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text"?: string;
    }
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface WcsGrid {
        /**
          * Contains the data to display in the table from a js object
         */
        "data"?: any[];
        /**
          * Flag to display a spinner during data loading
         */
        "loading"?: boolean;
        /**
          * Event emitted when all rows are selected or unselected
         */
        "onWcsGridAllSelectionChange"?: (event: WcsGridCustomEvent<WcsGridAllRowSelectedEventDetails>) => void;
        /**
          * Event emitted when a row is selected or unselected
         */
        "onWcsGridSelectionChange"?: (event: WcsGridCustomEvent<WcsGridRowSelectedEventDetails>) => void;
        /**
          * Name of the object's key that will be used to display the cells whose `keyValue` attribute matches to the object's value for this key.
         */
        "rowIdPath"?: string;
        /**
          * Set the selected items (rows)
         */
        "selectedItems"?: any | any[];
        /**
          * Used to manage grid's row selection.   "none": no row can be selected.   "multiple": several rows can be selected.   "single": one row only can be selected.
         */
        "selectionConfig"?: WcsGridSelectionConfig;
        /**
          * Manage sort and pagination with a backend server when set to `true`
         */
        "serverMode"?: boolean;
        /**
          * Automatically set by the component to reference the wcs-grid-pagination HTML element by its id.
         */
        "wcsGridPaginationId"?: string;
    }
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface WcsGridColumn {
        /**
          * Set to true if using a `wcs-custom-cell` linked to it.
         */
        "customCells"?: boolean;
        /**
          * Customizable formatter function to render the cell differently.
         */
        "formatter"?: WcsCellFormatter;
        /**
          * Flag to hide the column.
         */
        "hidden"?: boolean;
        /**
          * The name of the column displayed on the table (e.g: First Name, Last Name, Email, ...)
         */
        "name"?: string;
        /**
          * Event emitted if the column is dynamically switching visibility.
         */
        "onWcsHiddenChange"?: (event: WcsGridColumnCustomEvent<boolean>) => void;
        /**
          * Event emitted when the sort of the column is changed.
         */
        "onWcsSortChange"?: (event: WcsGridColumnCustomEvent<WcsGridColumnSortChangeEventDetails>) => void;
        /**
          * Represents the name of the field from the `data` object (e.g: first_name, last_name, email, ...)
         */
        "path"?: string;
        /**
          * Make the column sortable.
         */
        "sort"?: boolean;
        /**
          * Customizable sort function to change the comparison of values.
         */
        "sortFn"?: WcsSortFn;
        /**
          * Defines if the column sort is ascending or descending.   `none` = the column is not sorted.
         */
        "sortOrder"?: WcsSortOrder;
        /**
          * Set the column `<th>` element width.
         */
        "width"?: string;
    }
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId"?: string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId"?: any;
    }
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface WcsGridPagination {
        /**
          * Set the available page sizes in the pagination dropdown on the left.
         */
        "availablePageSizes"?: number[];
        /**
          * The current page of the pagination. First page starts at index 0.
         */
        "currentPage"?: number;
        /**
          * Total elements in the grid.   - **Grid in `Server mode`** : You have to set `itemsCount` = your total data length.   - **Grid not in Server mode** : Do not set it manually : itemsCount is set and updated every pagination refresh.
         */
        "itemsCount"?: number;
        /**
          * Event emitted when the pagination changes.
         */
        "onWcsGridPaginationChange"?: (event: WcsGridPaginationCustomEvent<WcsGridPaginationChangeEventDetails>) => void;
        /**
          * Max number of pages.   - **Grid in `Server mode`** : You have to set `pageCount` = `itemsCount` divided by `pageSize`.   - **Grid not in Server mode** : Do not set it manually : pageCount is set and updated every pagination refresh.
         */
        "pageCount"?: number;
        /**
          * Maximum number of elements shown per page.   Default is the first value of `availablePageSizes`.
         */
        "pageSize"?: number;
    }
    interface WcsHeader {
    }
    interface WcsHint {
        /**
          * Whether the component should display the small version of the hint
         */
        "small"?: boolean;
    }
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete"?: boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep"?: number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode"?: HorizontalStepperMode;
        /**
          * Emits when the user selects a new step.
         */
        "onWcsHorizontalStepClick"?: (event: WcsHorizontalStepperCustomEvent<HorizontalStepClickEvent>) => void;
        /**
          * steps to display
         */
        "steps"?: HorizontalStepConfig[];
    }
    interface WcsIcon {
        "icon"?: string;
        "size"?: 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    /**
     * Mainly inspired from Ionic Input Component
     */
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        "clearInput"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsInputCustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: WcsInputCustomEvent<KeyboardEvent>) => void;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * Specify the size (height) of the input.
         */
        "size"?: WcsInputSize;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    interface WcsLabel {
        "required"?: boolean;
    }
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated"?: boolean;
    }
    interface WcsListItemProperties {
    }
    interface WcsListItemProperty {
    }
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family"?: MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon"?: string;
        /**
          * Size of the icon
         */
        "size"?: MaterialIconSize;
    }
    interface WcsModal {
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions"?: boolean;
        /**
          * Triggered when the user leaves the dialog with the closing button.
         */
        "onWcsDialogClosed"?: (event: WcsModalCustomEvent<void>) => void;
        /**
          * Displays the modal
         */
        "show"?: boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton"?: boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size"?: ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop"?: boolean;
    }
    /**
     * The `wcs-native-select` component is designed to accept a native <select> element as a slotted child. This choice
     * allows developers to bind the <select> element using the framework of their choice, without the need to re-expose all the
     * properties of the <select> and <option> elements in this component.
     * The component wraps the native <select> element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * Example usage:
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     */
    interface WcsNativeSelect {
        /**
          * The `size` property controls the size of the slotted `select` element by adjusting its padding. There are two possible size options: - 'm': medium size - 'l': large size  The default value is 'm'.
         */
        "size"?: WcsNativeSelectSize;
    }
    interface WcsNav {
    }
    interface WcsNavItem {
        /**
          * Attributes mapped to a <a> tag.  Don't forget to specify [routerLink] if using in conjuction with angular router.
         */
        "href"?: string;
        /**
          * This attribute specify the text of the item.
         */
        "text"?: string;
    }
    /**
     * Component displaying progress as a bar.
     */
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel"?: boolean;
        /**
          * Whether the component display the small version
         */
        "small"?: boolean;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value"?: number;
    }
    interface WcsProgressRadial {
        "showLabel"?: boolean;
        "size"?: number;
        "value"?: number;
    }
    interface WcsRadio {
        /**
          * If `true`, the radio is selected.
         */
        "checked"?: boolean;
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled"?: boolean;
        "label"?: string;
        "mode"?: RadioGroupMode;
        "onWcsRadioClick"?: (event: WcsRadioCustomEvent<RadioChosedEvent>) => void;
        "value"?: any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        "mode"?: RadioGroupMode;
        "name"?: any;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        "value"?: any | any[] | undefined | null;
    }
    /**
     * Select component, use in conjuction with wcs-select-option.
     * @example ```hmtl
     * <wcs-select>
     * <wcs-select-option value="1">One</wcs-select-option>
     * </wcs-select>```
     */
    interface WcsSelect {
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips"?: boolean;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the select loses focus.
         */
        "onWcsBlur"?: (event: WcsSelectCustomEvent<void>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsSelectCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the select has focus.
         */
        "onWcsFocus"?: (event: WcsSelectCustomEvent<void>) => void;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * Specify the size (height) of the select.
         */
        "size"?: WcsSelectSize;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    /**
     * Select option component, use in conjunction with wcs-select.
     */
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Wether this option can be selected.
         */
        "disabled"?: boolean;
        /**
          * This property musn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple"?: boolean;
        "onWcsSelectOptionClick"?: (event: WcsSelectOptionCustomEvent<SelectOptionChosedEvent>) => void;
        /**
          * Wether this option is selected.
         */
        "selected"?: boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface WcsSkeletonCircle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the radius of the circle in px
         */
        "radius"?: number;
    }
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface WcsSkeletonRectangle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the height of the skeleton (can be any valid CSS value)
         */
        "height"?: CssTypes.Height;
        /**
          * Adds a border radius on the skeleton if true
         */
        "rounded"?: boolean;
        /**
          * Specifies the width of the skeleton (can be any valid CSS value)
         */
        "width"?: CssTypes.Width;
    }
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface WcsSkeletonText {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the line height of the text skeleton
         */
        "height"?: 'h1' | 'h2' | 'h3' | 'caption' | 'body';
    }
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode"?: WcsSpinnerMode;
    }
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment"?: SwitchLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsSwitchCustomEvent<SwitchChangeEventDetail>) => void;
    }
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header"?: string;
        "itemKey"?: any;
        /**
          * Do not use, meant for internal use only.
          * @inner 
          * @ignore
         */
        "onTabLoaded"?: (event: WcsTabCustomEvent<void>) => void;
    }
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     */
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align"?: WcsTabsAlignment;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter"?: boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly"?: boolean;
        /**
          * Emitted when the selected tab change.
         */
        "onTabChange"?: (event: WcsTabsCustomEvent<WcsTabChangeEvent>) => void;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex"?: number;
        "selectedKey"?: any;
    }
    /**
     * Mainly inspired from Ionic Textarea Component
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     */
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow"?: boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize"?: string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        "clearOnEdit"?: boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display. Possible values: `"enter"`, `"done"`, `"go"`, `"next"`, `"previous"`, `"search"`, and `"send"`.
         */
        "enterkeyhint"?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send';
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search';
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input value has changed.
         */
        "onWcsChange"?: (event: WcsTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onWcsInput"?: (event: WcsTextareaCustomEvent<KeyboardEvent>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * Indicates how the textarea should be resizable. Possible values 'both' | 'none' | 'vertical' | 'horizontal'
         */
        "resize"?: 'both' | 'none' | 'vertical' | 'horizontal';
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: 'initial' | 'error';
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: 'hard' | 'soft' | 'off';
    }
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     */
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo"?: WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content"?: string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay"?: number | [number, number];
        /**
          * Duration in ms of the transition animation.
         */
        "duration"?: number | [number, number];
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for"?: string;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive"?: boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.
         */
        "maxWidth"?: string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position"?: WcsTooltipPosition;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme"?: string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger"?: string;
    }
    interface IntrinsicElements {
        "wcs-accordion": WcsAccordion;
        "wcs-accordion-content": WcsAccordionContent;
        "wcs-accordion-header": WcsAccordionHeader;
        "wcs-accordion-panel": WcsAccordionPanel;
        "wcs-action-bar": WcsActionBar;
        "wcs-app": WcsApp;
        "wcs-badge": WcsBadge;
        "wcs-button": WcsButton;
        "wcs-card": WcsCard;
        "wcs-card-body": WcsCardBody;
        "wcs-checkbox": WcsCheckbox;
        "wcs-com-nav": WcsComNav;
        "wcs-com-nav-category": WcsComNavCategory;
        "wcs-com-nav-submenu": WcsComNavSubmenu;
        "wcs-counter": WcsCounter;
        "wcs-divider": WcsDivider;
        "wcs-dropdown": WcsDropdown;
        "wcs-dropdown-divider": WcsDropdownDivider;
        "wcs-dropdown-header": WcsDropdownHeader;
        "wcs-dropdown-item": WcsDropdownItem;
        "wcs-editable-field": WcsEditableField;
        "wcs-error": WcsError;
        "wcs-field": WcsField;
        "wcs-field-content": WcsFieldContent;
        "wcs-field-label": WcsFieldLabel;
        "wcs-footer": WcsFooter;
        "wcs-form-field": WcsFormField;
        "wcs-galactic": WcsGalactic;
        "wcs-galactic-menu": WcsGalacticMenu;
        "wcs-grid": WcsGrid;
        "wcs-grid-column": WcsGridColumn;
        "wcs-grid-custom-cell": WcsGridCustomCell;
        "wcs-grid-pagination": WcsGridPagination;
        "wcs-header": WcsHeader;
        "wcs-hint": WcsHint;
        "wcs-horizontal-stepper": WcsHorizontalStepper;
        "wcs-icon": WcsIcon;
        "wcs-input": WcsInput;
        "wcs-label": WcsLabel;
        "wcs-list-item": WcsListItem;
        "wcs-list-item-properties": WcsListItemProperties;
        "wcs-list-item-property": WcsListItemProperty;
        "wcs-mat-icon": WcsMatIcon;
        "wcs-modal": WcsModal;
        "wcs-native-select": WcsNativeSelect;
        "wcs-nav": WcsNav;
        "wcs-nav-item": WcsNavItem;
        "wcs-progress-bar": WcsProgressBar;
        "wcs-progress-radial": WcsProgressRadial;
        "wcs-radio": WcsRadio;
        "wcs-radio-group": WcsRadioGroup;
        "wcs-select": WcsSelect;
        "wcs-select-option": WcsSelectOption;
        "wcs-skeleton-circle": WcsSkeletonCircle;
        "wcs-skeleton-rectangle": WcsSkeletonRectangle;
        "wcs-skeleton-text": WcsSkeletonText;
        "wcs-spinner": WcsSpinner;
        "wcs-switch": WcsSwitch;
        "wcs-tab": WcsTab;
        "wcs-tabs": WcsTabs;
        "wcs-textarea": WcsTextarea;
        "wcs-tooltip": WcsTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wcs-accordion": LocalJSX.WcsAccordion & JSXBase.HTMLAttributes<HTMLWcsAccordionElement>;
            "wcs-accordion-content": LocalJSX.WcsAccordionContent & JSXBase.HTMLAttributes<HTMLWcsAccordionContentElement>;
            "wcs-accordion-header": LocalJSX.WcsAccordionHeader & JSXBase.HTMLAttributes<HTMLWcsAccordionHeaderElement>;
            "wcs-accordion-panel": LocalJSX.WcsAccordionPanel & JSXBase.HTMLAttributes<HTMLWcsAccordionPanelElement>;
            "wcs-action-bar": LocalJSX.WcsActionBar & JSXBase.HTMLAttributes<HTMLWcsActionBarElement>;
            "wcs-app": LocalJSX.WcsApp & JSXBase.HTMLAttributes<HTMLWcsAppElement>;
            "wcs-badge": LocalJSX.WcsBadge & JSXBase.HTMLAttributes<HTMLWcsBadgeElement>;
            /**
             * Button component, can also be a link when specifying href.
             * ## Click event
             * The WCS button relies on the native click event to pass a user click to your app.
             * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
             * This means you'll receive click events on a disabled wcs button.
             * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
             * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
             */
            "wcs-button": LocalJSX.WcsButton & JSXBase.HTMLAttributes<HTMLWcsButtonElement>;
            "wcs-card": LocalJSX.WcsCard & JSXBase.HTMLAttributes<HTMLWcsCardElement>;
            "wcs-card-body": LocalJSX.WcsCardBody & JSXBase.HTMLAttributes<HTMLWcsCardBodyElement>;
            "wcs-checkbox": LocalJSX.WcsCheckbox & JSXBase.HTMLAttributes<HTMLWcsCheckboxElement>;
            "wcs-com-nav": LocalJSX.WcsComNav & JSXBase.HTMLAttributes<HTMLWcsComNavElement>;
            "wcs-com-nav-category": LocalJSX.WcsComNavCategory & JSXBase.HTMLAttributes<HTMLWcsComNavCategoryElement>;
            "wcs-com-nav-submenu": LocalJSX.WcsComNavSubmenu & JSXBase.HTMLAttributes<HTMLWcsComNavSubmenuElement>;
            /**
             * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
             * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
             */
            "wcs-counter": LocalJSX.WcsCounter & JSXBase.HTMLAttributes<HTMLWcsCounterElement>;
            "wcs-divider": LocalJSX.WcsDivider & JSXBase.HTMLAttributes<HTMLWcsDividerElement>;
            "wcs-dropdown": LocalJSX.WcsDropdown & JSXBase.HTMLAttributes<HTMLWcsDropdownElement>;
            "wcs-dropdown-divider": LocalJSX.WcsDropdownDivider & JSXBase.HTMLAttributes<HTMLWcsDropdownDividerElement>;
            "wcs-dropdown-header": LocalJSX.WcsDropdownHeader & JSXBase.HTMLAttributes<HTMLWcsDropdownHeaderElement>;
            "wcs-dropdown-item": LocalJSX.WcsDropdownItem & JSXBase.HTMLAttributes<HTMLWcsDropdownItemElement>;
            "wcs-editable-field": LocalJSX.WcsEditableField & JSXBase.HTMLAttributes<HTMLWcsEditableFieldElement>;
            "wcs-error": LocalJSX.WcsError & JSXBase.HTMLAttributes<HTMLWcsErrorElement>;
            "wcs-field": LocalJSX.WcsField & JSXBase.HTMLAttributes<HTMLWcsFieldElement>;
            "wcs-field-content": LocalJSX.WcsFieldContent & JSXBase.HTMLAttributes<HTMLWcsFieldContentElement>;
            "wcs-field-label": LocalJSX.WcsFieldLabel & JSXBase.HTMLAttributes<HTMLWcsFieldLabelElement>;
            "wcs-footer": LocalJSX.WcsFooter & JSXBase.HTMLAttributes<HTMLWcsFooterElement>;
            /**
             * TODO:
             * - [ ] Suffix button style
             */
            "wcs-form-field": LocalJSX.WcsFormField & JSXBase.HTMLAttributes<HTMLWcsFormFieldElement>;
            "wcs-galactic": LocalJSX.WcsGalactic & JSXBase.HTMLAttributes<HTMLWcsGalacticElement>;
            "wcs-galactic-menu": LocalJSX.WcsGalacticMenu & JSXBase.HTMLAttributes<HTMLWcsGalacticMenuElement>;
            /**
             * The grid component is a complex component used as an HTML table to display collections of data.
             * @cssprop --wcs-grid-highlight-color - Color for selected rows
             * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
             */
            "wcs-grid": LocalJSX.WcsGrid & JSXBase.HTMLAttributes<HTMLWcsGridElement>;
            /**
             * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
             * @cssprop --wcs-grid-column-border-left - Border separator between column names
             * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
             */
            "wcs-grid-column": LocalJSX.WcsGridColumn & JSXBase.HTMLAttributes<HTMLWcsGridColumnElement>;
            /**
             * The grid custom cell is a subcomponent of `wcs-grid`.
             */
            "wcs-grid-custom-cell": LocalJSX.WcsGridCustomCell & JSXBase.HTMLAttributes<HTMLWcsGridCustomCellElement>;
            /**
             * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
             */
            "wcs-grid-pagination": LocalJSX.WcsGridPagination & JSXBase.HTMLAttributes<HTMLWcsGridPaginationElement>;
            "wcs-header": LocalJSX.WcsHeader & JSXBase.HTMLAttributes<HTMLWcsHeaderElement>;
            "wcs-hint": LocalJSX.WcsHint & JSXBase.HTMLAttributes<HTMLWcsHintElement>;
            "wcs-horizontal-stepper": LocalJSX.WcsHorizontalStepper & JSXBase.HTMLAttributes<HTMLWcsHorizontalStepperElement>;
            "wcs-icon": LocalJSX.WcsIcon & JSXBase.HTMLAttributes<HTMLWcsIconElement>;
            /**
             * Mainly inspired from Ionic Input Component
             */
            "wcs-input": LocalJSX.WcsInput & JSXBase.HTMLAttributes<HTMLWcsInputElement>;
            "wcs-label": LocalJSX.WcsLabel & JSXBase.HTMLAttributes<HTMLWcsLabelElement>;
            "wcs-list-item": LocalJSX.WcsListItem & JSXBase.HTMLAttributes<HTMLWcsListItemElement>;
            "wcs-list-item-properties": LocalJSX.WcsListItemProperties & JSXBase.HTMLAttributes<HTMLWcsListItemPropertiesElement>;
            "wcs-list-item-property": LocalJSX.WcsListItemProperty & JSXBase.HTMLAttributes<HTMLWcsListItemPropertyElement>;
            "wcs-mat-icon": LocalJSX.WcsMatIcon & JSXBase.HTMLAttributes<HTMLWcsMatIconElement>;
            "wcs-modal": LocalJSX.WcsModal & JSXBase.HTMLAttributes<HTMLWcsModalElement>;
            /**
             * The `wcs-native-select` component is designed to accept a native <select> element as a slotted child. This choice
             * allows developers to bind the <select> element using the framework of their choice, without the need to re-expose all the
             * properties of the <select> and <option> elements in this component.
             * The component wraps the native <select> element and provides custom styles and behavior, while preserving the native
             * functionality and accessibility.
             * Example usage:
             * <wcs-native-select>
             *   <select>
             *     <option value="option1">Option 1</option>
             *     <option value="option2">Option 2</option>
             *     <option value="option3">Option 3</option>
             *   </select>
             * </wcs-native-select>
             */
            "wcs-native-select": LocalJSX.WcsNativeSelect & JSXBase.HTMLAttributes<HTMLWcsNativeSelectElement>;
            "wcs-nav": LocalJSX.WcsNav & JSXBase.HTMLAttributes<HTMLWcsNavElement>;
            "wcs-nav-item": LocalJSX.WcsNavItem & JSXBase.HTMLAttributes<HTMLWcsNavItemElement>;
            /**
             * Component displaying progress as a bar.
             */
            "wcs-progress-bar": LocalJSX.WcsProgressBar & JSXBase.HTMLAttributes<HTMLWcsProgressBarElement>;
            "wcs-progress-radial": LocalJSX.WcsProgressRadial & JSXBase.HTMLAttributes<HTMLWcsProgressRadialElement>;
            "wcs-radio": LocalJSX.WcsRadio & JSXBase.HTMLAttributes<HTMLWcsRadioElement>;
            "wcs-radio-group": LocalJSX.WcsRadioGroup & JSXBase.HTMLAttributes<HTMLWcsRadioGroupElement>;
            /**
             * Select component, use in conjuction with wcs-select-option.
             * @example ```hmtl
             * <wcs-select>
             * <wcs-select-option value="1">One</wcs-select-option>
             * </wcs-select>```
             */
            "wcs-select": LocalJSX.WcsSelect & JSXBase.HTMLAttributes<HTMLWcsSelectElement>;
            /**
             * Select option component, use in conjunction with wcs-select.
             */
            "wcs-select-option": LocalJSX.WcsSelectOption & JSXBase.HTMLAttributes<HTMLWcsSelectOptionElement>;
            /**
             * Use a skeleton circle as a placeholder round images, illustrations or components
             */
            "wcs-skeleton-circle": LocalJSX.WcsSkeletonCircle & JSXBase.HTMLAttributes<HTMLWcsSkeletonCircleElement>;
            /**
             * Use a skeleton rectangle as a placeholder for large images or square-shaped components
             * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
             */
            "wcs-skeleton-rectangle": LocalJSX.WcsSkeletonRectangle & JSXBase.HTMLAttributes<HTMLWcsSkeletonRectangleElement>;
            /**
             * Use a skeleton text as a placeholder for titles or paragraphs.
             */
            "wcs-skeleton-text": LocalJSX.WcsSkeletonText & JSXBase.HTMLAttributes<HTMLWcsSkeletonTextElement>;
            "wcs-spinner": LocalJSX.WcsSpinner & JSXBase.HTMLAttributes<HTMLWcsSpinnerElement>;
            "wcs-switch": LocalJSX.WcsSwitch & JSXBase.HTMLAttributes<HTMLWcsSwitchElement>;
            /**
             * Tab content component.
             * Use this component to specify the content of a component.
             */
            "wcs-tab": LocalJSX.WcsTab & JSXBase.HTMLAttributes<HTMLWcsTabElement>;
            /**
             * Tabs component to switch between tab content.
             * Use in conjuction with `wcs-tab`.
             * @example ```html
             * <wcs-tabs>
             *    <wcs-tab header="One">The content !</wcs-tab>
             *    <wcs-tab header="Two">More content !</wcs-tab>
             * </wcs-tabs>
             * ```
             */
            "wcs-tabs": LocalJSX.WcsTabs & JSXBase.HTMLAttributes<HTMLWcsTabsElement>;
            /**
             * Mainly inspired from Ionic Textarea Component
             * @cssprop --wcs-textarea-max-height - Max height of the text area component
             */
            "wcs-textarea": LocalJSX.WcsTextarea & JSXBase.HTMLAttributes<HTMLWcsTextareaElement>;
            /**
             * Tooltips are used to provide additional information for features available on the website. These can improve the user
             * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
             * (for longer content).
             * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
             */
            "wcs-tooltip": LocalJSX.WcsTooltip & JSXBase.HTMLAttributes<HTMLWcsTooltipElement>;
        }
    }
}
