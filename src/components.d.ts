/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AriaAttributeName } from "./utils/mutable-aria-attribute";
import { BadgeColor, BadgeShape, BadgeSize } from "./components/badge/badge-interface";
import { WcsButtonMode, WcsButtonShape, WcsButtonSize, WcsButtonType } from "./components/button/button-interface";
import { CardMode } from "./components/card/card-interface";
import { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
import { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
import { CounterChangeEventDetail, WcsCounterSize } from "./components/counter/counter-interface";
import { WcsDropdownPlacement } from "./components/dropdown/dropdown-interface";
import { EditableComponentUpdateEvent, EditableFieldType, FormatFn, ValidateFn, WcsEditableFieldSize } from "./components/editable-field/editable-field-interface";
import { RowCssPartsFn, WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridSelectionConfig, WcsGridSelectionEventDetails, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
import { HorizontalStepClickEvent, HorizontalStepConfig, HorizontalStepperMode } from "./components/horizontal-stepper/horizontal-stepper-interface";
import { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes, WcsInputAutocorrect, WcsInputEnterKeyHint, WcsInputInputMode, WcsInputSize, WcsInputState } from "./components/input/input-interface";
import { MaterialIconFamily, MaterialIconSize } from "./components/mat-icon/mat-icon-interface";
import { ModalSize } from "./components/modal/modal-interface";
import { WcsNativeSelectSize } from "./components/native-select/native-select-interface";
import { CssTypes, WcsSize } from "./shared-types";
import { RadioGroupChangeEventDetail, RadioGroupMode } from "./components/radio-group/radio-group-interface";
import { RadioChosedEvent } from "./components/radio/radio-interface";
import { SelectChangeEventDetail, SelectFilterChangeEventDetail, WcsSelectFilterFn, WcsSelectSize } from "./components/select/select-interface";
import { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
import { WcsSkeletonAnimation } from "./components/skeleton/skeleton-interface";
import { WcsSpinnerMode } from "./components/spinner/spinner-interface";
import { SwitchChangeEventDetail, SwitchLabelAlignment } from "./components/switch/switch-interface";
import { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
import { TextareaChangeEventDetail, WcsTextareaEnterKeyHint, WcsTextareaInputMode, WcsTextareaInputState, WcsTextareaResize, WcsTextareaWrap } from "./components/textarea/textarea-interface";
import { WcsTooltipAppendTo, WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export { AriaAttributeName } from "./utils/mutable-aria-attribute";
export { BadgeColor, BadgeShape, BadgeSize } from "./components/badge/badge-interface";
export { WcsButtonMode, WcsButtonShape, WcsButtonSize, WcsButtonType } from "./components/button/button-interface";
export { CardMode } from "./components/card/card-interface";
export { CheckboxChangeEventDetail, CheckboxLabelAlignment } from "./components/checkbox/checkbox-interface";
export { CategoryOpenedEventDetail, MenuOpenedEventDetail } from "./components/com-nav/com-nav-interface";
export { CounterChangeEventDetail, WcsCounterSize } from "./components/counter/counter-interface";
export { WcsDropdownPlacement } from "./components/dropdown/dropdown-interface";
export { EditableComponentUpdateEvent, EditableFieldType, FormatFn, ValidateFn, WcsEditableFieldSize } from "./components/editable-field/editable-field-interface";
export { RowCssPartsFn, WcsCellFormatter, WcsGridAllRowSelectedEventDetails, WcsGridColumnSortChangeEventDetails, WcsGridPaginationChangeEventDetails, WcsGridSelectionConfig, WcsGridSelectionEventDetails, WcsSortFn, WcsSortOrder } from "./components/grid/grid-interface";
export { HorizontalStepClickEvent, HorizontalStepConfig, HorizontalStepperMode } from "./components/horizontal-stepper/horizontal-stepper-interface";
export { AutocompleteTypes, InputChangeEventDetail, TextFieldTypes, WcsInputAutocorrect, WcsInputEnterKeyHint, WcsInputInputMode, WcsInputSize, WcsInputState } from "./components/input/input-interface";
export { MaterialIconFamily, MaterialIconSize } from "./components/mat-icon/mat-icon-interface";
export { ModalSize } from "./components/modal/modal-interface";
export { WcsNativeSelectSize } from "./components/native-select/native-select-interface";
export { CssTypes, WcsSize } from "./shared-types";
export { RadioGroupChangeEventDetail, RadioGroupMode } from "./components/radio-group/radio-group-interface";
export { RadioChosedEvent } from "./components/radio/radio-interface";
export { SelectChangeEventDetail, SelectFilterChangeEventDetail, WcsSelectFilterFn, WcsSelectSize } from "./components/select/select-interface";
export { SelectOptionChosedEvent } from "./components/select-option/select-option-interface";
export { WcsSkeletonAnimation } from "./components/skeleton/skeleton-interface";
export { WcsSpinnerMode } from "./components/spinner/spinner-interface";
export { SwitchChangeEventDetail, SwitchLabelAlignment } from "./components/switch/switch-interface";
export { WcsTabChangeEvent, WcsTabsAlignment } from "./components/tabs/tabs-interface";
export { TextareaChangeEventDetail, WcsTextareaEnterKeyHint, WcsTextareaInputMode, WcsTextareaInputState, WcsTextareaResize, WcsTextareaWrap } from "./components/textarea/textarea-interface";
export { WcsTooltipAppendTo, WcsTooltipPosition } from "./components/tooltip/tooltip-interface";
export namespace Components {
    /**
     * The accordion component is a vertical stack of interactive headings used to toggle the display of further information.
     */
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight": boolean;
    }
    /**
     * The accordion-content is a subcomponent of `wcs-accordion`. It represents the text / content below an expanded accordion.
     */
    interface WcsAccordionContent {
    }
    /**
     * The accordion-header is a subcomponent of `wcs-accordion`. It represents the heading text inside the accordion panel.
     */
    interface WcsAccordionHeader {
    }
    /**
     * The accordion-panel is a subcomponent of `wcs-accordion`. It represents every panel of the accordion that can be expanded.
     */
    interface WcsAccordionPanel {
        "close": () => Promise<void>;
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader": boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText": boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight": boolean;
        "open": boolean;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The action-bar component is a group of elements appearing across the top of all pages on a business application.
     */
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter": boolean;
    }
    interface WcsApp {
    }
    /**
     * The badge component is a small label, generally appearing inside or in proximity to another larger interface component,
     * representing a status, property, or some other metadata.
     * @cssprop --wcs-badge-ligther-percentage - Define the opacity rate to apply to the badge
     */
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color": BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape": BadgeShape;
        /**
          * Specify the size of the badge.
         */
        "size": BadgeSize;
    }
    /**
     * A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order.  
     * It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.  
     * ## Accessibility guidelines 💡
     * > If the last item is a link to the current page, you must set the `aria-current` attribute to `page`.  
     * > If the element representing the current page is not a link, aria-current is optional.
     */
    interface WcsBreadcrumb {
    }
    interface WcsBreadcrumbItem {
    }
    /**
     * The button component is used to trigger an action. It can also be a link when specifying href.
     * ## Accessibility guidelines 💡
     * > If your button doesn't contain text but only an image, you must set a relevant aria-label on the icon 👉 [see "Square" story below](#square)
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface WcsButton {
        /**
          * Specify whether the button is disabled or not.
         */
        "disabled": boolean;
        /**
          * Set a URL to point to.<br/> If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading": boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode": WcsButtonMode;
        /**
          * Specify whether the button should have a ripple effect or not.
         */
        "ripple": boolean;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Specify the shape of the button.
         */
        "shape": WcsButtonShape;
        /**
          * Specify the size of the button.
         */
        "size": WcsButtonSize;
        /**
          * Specifies where to open the linked document when using href (see prop above)<br/> Default '_self' will open the linked document in the same frame as it was clicked
         */
        "target"?: '_blank' | '_self';
        /**
          * Specify the button type.
         */
        "type": WcsButtonType;
    }
    /**
     * The card component is a container that display content such as text, images, buttons, and lists.  
     * A card can be a single component, but is often made up of a header, title, subtitle, and content.
     */
    interface WcsCard {
        "mode": CardMode;
    }
    /**
     * The card-body is a subcomponent of `wcs-card`. It represents content of the card with an extra padding around.
     */
    interface WcsCardBody {
    }
    /**
     * The checkbox component is an input for choosing one or more items from a set by checking / unchecking it.
     */
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled": boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment": CheckboxLabelAlignment;
        "name": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * *Part of communication design system*
     * The com-nav component is a container for navigation links to external or internal pages of the website.
     */
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The com-nav-category is a subcomponent of `wcs-com-nav`. It represents a category nested inside a `wcs-com-nav-submenu`.
     */
    interface WcsComNavCategory {
        /**
          * Close the category
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the category
         */
        "open": () => Promise<void>;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The com-nav-item is a subcomponent of `wcs-com-nav`. It represents a list-item wrapper around a link.
     */
    interface WcsComNavItem {
    }
    /**
     * The com-nav-submenu is a subcomponent of `wcs-com-nav`. It represents an expandable menu containing more items or categories.
     */
    interface WcsComNavSubmenu {
        /**
          * Close the menu
         */
        "close": () => Promise<void>;
        "label": string;
        /**
          * Opens the menu
         */
        "open": () => Promise<void>;
        "panelDescription": string;
        "panelTitle": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface WcsCounter {
        /**
          * Specify whether the counter is disabled or not.
         */
        "disabled": boolean;
        /**
          * The label of the counter.<br/> e.g. Number of passengers, train carriages, railroad tracks...
         */
        "label": string;
        /**
          * The maximum value of the counter. If the value of the max attribute isn't set, then the element has no maximum value.
         */
        "max"?: number;
        /**
          * The minimum value of the counter. If the value of the min attribute isn't set, then the element has no minimum value.
         */
        "min"?: number;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Specify the size (height) of the counter.
         */
        "size": WcsCounterSize;
        /**
          * Defines by how much the counter will be incremented or decremented.
         */
        "step": number;
        /**
          * The current value of the counter.
         */
        "value": number;
    }
    interface WcsDivider {
    }
    /**
     * The dropdown component use a wcs-button under the hood, so you can use the same css classes as the button to style the
     * dropdown.
     */
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled": boolean;
        /**
          * Dropdown's button mode
         */
        "mode": WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow": boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement": WcsDropdownPlacement;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Dropdown's button shape
         */
        "shape": WcsButtonShape;
        /**
          * Dropdown's button size
         */
        "size": WcsButtonSize;
    }
    /**
     * You can add a divider between groups of items
     */
    interface WcsDropdownDivider {
    }
    /**
     * You can add `wcs-dropdown-header` before a group of items to describe it
     */
    interface WcsDropdownHeader {
    }
    /**
     * You must add `wcs-dropdown-item` to `wcs-dropdown`
     */
    interface WcsDropdownItem {
    }
    /**
     * The editable-field component can be used to simplify the user experience, avoiding the use of a redirection to a form
     * to edit the data of an entity. You can use it with these wrapped components : `wcs-input`, `wcs-textarea`, `wcs-select`. 
     * This component is not present in the SNCF design system specifications, so we tried to build it in the most
     * "discoverable" way possible (for users who interact with), but it's a first version.
     * **How to use ❓**  
     * This component is mostly used with a server that returns a response to the input sent through the `wcsChange` event.
     * It has 3 internal states :
     * - DISPLAY = the default state of the editable-field
     * - EDIT = the editable-field is editable, the user should input the data
     * - LOADING = the data is submitted and the editable-field is waiting for a **response**
     * A **response** is needed to get the component out of the LOADING state. You can either :
     * - Set the `value` property to a different value to tell the component to refresh and go back into DISPLAY state
     * - Use the `successHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * - Use the `errorHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * **Accessibility guidelines 💡**  
     * > - Aria attributes are put on the native component on the first rendering with the `label` and `errorMsg` you provided 
     * > - Additional aria attributes put on `<wcs-editable-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg": string;
        /**
          * Function used to format the value
         */
        "formatFn": FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * Specify whether the field is editable or not
         */
        "readonly": boolean;
        /**
          * Specify the size (height) of the editable field.
         */
        "size": WcsEditableFieldSize;
        /**
          * Specifies which component is used for editing
         */
        "type": EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn": ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value": any;
    }
    /**
     * The `wcs-error` should always be wrapped in a `wcs-form-field`.
     * It is used to display a red message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant error message to inform the users what they should change to make the field valid
     * - `aria-description` will be automatically added to the field for screen readers
     * - `aria-invalid="true"` will be automatically added to the field for screen readers
     */
    interface WcsError {
    }
    /**
     * This field component can be used to display the details of an entity. It is built around the label and the content of the field.
     */
    interface WcsField {
    }
    /**
     * The field-content is a subcomponent of `wcs-field`. It represents the text content of the field.
     */
    interface WcsFieldContent {
    }
    /**
     * The field-label is a subcomponent of `wcs-field`. It represents the label or title of the field.
     */
    interface WcsFieldLabel {
    }
    /**
     * The footer component has been designed to leave as much customization as possible to the developer. The footers are often specific to the application developed.
     */
    interface WcsFooter {
    }
    /**
     * Form field component wraps the native input element and add some more functionality on top of it.
     * You can use the `wcs-form-field` to wrap any of these components :
     * - `wcs-input`
     * - `wcs-textarea`
     * - `wcs-radio-group`
     * - `wcs-switch`
     * - `wcs-checkbox`
     * - `wcs-native-select`
     * - `wcs-select`
     * - `wcs-counter`
     * For non-supported slotted component, you can use the `required` attribute on the wrapped component to tell the
     * form-field that it is required. It will add a red star after the label of the form field.
     * ## Accessibility guidelines 💡
     * - Each form control should be identified with a unique `wcs-label`
     * - Don't forget to add form validation to make sure the data is correctly formatted
     * - If the `wcs-label` is required, the form control must have the `required` HTML attribute and vice-versa (this is normally automatically set)
     * - The form should not be submittable if at least one required form control is not filled
     * - Hints are optional and should only be used to add extra information
     * - Additional aria attributes put on `<wcs-form-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError": boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text": string;
    }
    interface WcsGalacticMenu {
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Text to be displayed in the galactic bar
         */
        "text": string;
    }
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface WcsGrid {
        /**
          * Contains the data to display in the table from a js object
         */
        "data": any[];
        /**
          * Flag to display a spinner during data loading
         */
        "loading": boolean;
        /**
          * Function to add css parts to the grid rows, this allows you to customize the rows with css parts directly in you're application stylesheet.
         */
        "rowCssPartsFn": RowCssPartsFn;
        /**
          * Name of the object's key that will be used to display the cells whose `keyValue` attribute matches to the object's value for this key.
         */
        "rowIdPath": string;
        /**
          * Set the selected items (rows)
         */
        "selectedItems": any | any[];
        /**
          * Used to manage grid's row selection.   "none": no row can be selected.   "multiple": several rows can be selected.   "single": one row only can be selected.
         */
        "selectionConfig": WcsGridSelectionConfig;
        /**
          * Manage sort and pagination with a backend server when set to `true`
         */
        "serverMode": boolean;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Automatically set by the component to reference the wcs-grid-pagination HTML element by its id.
         */
        "wcsGridPaginationId": string;
    }
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface WcsGridColumn {
        /**
          * This property mustn't be set by hand, it is set by the wcs-grid component to register the column index in a grid in order to move the focus between the grid columns.
         */
        "columnPosition": number;
        /**
          * This property mustn't be set by hand, it is set by the wcs-grid component to move the focus between grid columns using keyboard.
         */
        "cursorPosition": {col: number, row: number};
        /**
          * Set to true if using a `wcs-custom-cell` linked to it.
         */
        "customCells": boolean;
        /**
          * Customizable formatter function to render the cell differently.
         */
        "formatter": WcsCellFormatter;
        /**
          * Flag to hide the column.
         */
        "hidden": boolean;
        /**
          * The name of the column displayed on the table (e.g: First Name, Last Name, Email, ...)
         */
        "name": string;
        /**
          * Represents the name of the field from the `data` object (e.g: first_name, last_name, email, ...)
         */
        "path": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Make the column sortable.
         */
        "sort": boolean;
        /**
          * Customizable sort function to change the comparison of values.
         */
        "sortFn": WcsSortFn;
        /**
          * Defines if the column sort is ascending or descending.   `none` = the column is not sorted.
         */
        "sortOrder": WcsSortOrder;
        /**
          * Set the column `<th>` element width.
         */
        "width": string;
    }
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId": string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId": any;
    }
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface WcsGridPagination {
        /**
          * Set the available page sizes in the pagination dropdown on the left.
         */
        "availablePageSizes": number[];
        /**
          * The current page of the pagination. First page starts at index 0.
         */
        "currentPage": number;
        /**
          * Total elements in the grid.   - **Grid in `Server mode`** : You have to set `itemsCount` = your total data length.   - **Grid not in Server mode** : Do not set it manually : itemsCount is set and updated every pagination refresh.
         */
        "itemsCount": number;
        /**
          * Max number of pages.   - **Grid in `Server mode`** : You have to set `pageCount` = `itemsCount` divided by `pageSize`.   - **Grid not in Server mode** : Do not set it manually : pageCount is set and updated every pagination refresh.
         */
        "pageCount": number;
        /**
          * Maximum number of elements shown per page.   Default is the first value of `availablePageSizes`.
         */
        "pageSize": number;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The header component is an element that appears across the top of all pages on a website or application; it contains the logo, the site name and main actions.
     */
    interface WcsHeader {
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The `wcs-hint` should always be wrapped in a `wcs-form-field`.
     * It is used to display an informative message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant hint message to inform the users about the format, how the data should be filled in, or what is the purpose of the field
     * - `aria-description` will be automatically added to the field for screen readers
     */
    interface WcsHint {
        /**
          * Whether the component should display the small version of the hint
         */
        "small": boolean;
    }
    /**
     * The horizontal-stepper is a representation of a user’s progress through a series of discrete steps.
     */
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete": boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep": number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode": HorizontalStepperMode;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        /**
          * steps to display
         */
        "steps": HorizontalStepConfig[];
    }
    /**
     * The icon component is a graphic symbol designed to visually indicate the purpose of an interface element.
     */
    interface WcsIcon {
        "icon": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        "size": 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    /**
     * The input component is a form control that accepts a single line of text.
     * Implementation mainly inspired from Ionic Input Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-input outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     */
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize": string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete": AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect": WcsInputAutocorrect;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsInput` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display.
         */
        "enterkeyhint"?: WcsInputEnterKeyHint;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * Returns the native `<input>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display.
         */
        "inputmode"?: WcsInputInputMode;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel": string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Sets blur on the native `input` in `wcs-input`. Use this method instead of the global `input.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * Specify the size (height) of the input.
         */
        "size": WcsInputSize;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state": WcsInputState;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel": string;
        /**
          * The type of control to display. The default type is text.
         */
        "type": TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    /**
     * The `wcs-label` should always be wrapped in a `wcs-form-field`.
     * It is used to caption a form control component.
     * ## Accessibility guidelines 💡
     * - Use concise name for the label. If you want to describe more your form control, add a `wcs-hint`
     * - Use the required flag only as an indication to inform users that the form control is required
     */
    interface WcsLabel {
        /**
          * If `true`, marks the label with a red star. Automatically added if the wrapped component inside the `wcs-form-field` already has the `required` attribute.
         */
        "required": boolean;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * Lists are used for grouping a collection of related items.
     * Standard lists can be used either with or without icons. Depending on the context, the list can have one or more
     * actions (favourite, download, delete, etc.). Use standard lists with a unique action when each line has an action.
     */
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated": boolean;
    }
    /**
     * The list-item-properties is a subcomponent of `wcs-list-item`. It represents a wrapper for a list of several `wcs-property`.
     */
    interface WcsListItemProperties {
    }
    /**
     * The list-item-property is a subcomponent of `wcs-list-item`.
     * Wrapped in a `wcs-list-item-properties`, it represents a property to describe an item.
     */
    interface WcsListItemProperty {
    }
    /**
     * A component used to display a [Material Icon](https://fonts.google.com/icons). Can be useful when used in wcs-grid or in a wcs-button.
     */
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family": MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Size of the icon
         */
        "size": MaterialIconSize;
    }
    /**
     * The modal component (also named dialog or popup) is an interface element that appears on top of the page content.
     * Use it to show a message, a confirmation dialog, or any other content like forms.
     * ## Accessibility guidelines 💡
     * > - Modal element has `role="dialog"` and `aria-modal="true"`
     * > - Keyboard navigation is trapped inside the modal
     * > - It is mandatory to set the `modal-trigger-controls-id` to the id of the element that opens the dialog, in order
     * > to focus it upon dialog dismissal.
     * > - The modal can be closed at any time by pressing the Escape key.
     * >
     * > - More info : https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/
     * @cssprop --wcs-modal-max-height - Max height of the main container
     * @cssprop --wcs-modal-overflow-y - Overflow-y of the content
     */
    interface WcsModal {
        /**
          * Specifies the aria-label present on the close button when the modal is opened.   Only use when `showCloseButton` is `true`.
         */
        "closeButtonAriaLabel": string;
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions": boolean;
        /**
          * Specifies which element id controls the modal
          * @private
         */
        "modalTriggerControlsId": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Displays the modal
         */
        "show": boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton": boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size": ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop": boolean;
    }
    /**
     * The `wcs-native-select` component is designed to accept a native `<select>` element as a slotted child. This choice
     * allows developers to bind the `<select>` element using the framework of their choice, without the need to re-expose all the
     * properties of the `<select>` and `<option>` elements in this component.
     * The component wraps the native `<select>` element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * ### ✅ Guidance
     * - To have a placeholder, you must have an option as child which has `selected` attribute and `disabled`
     * attribute. You can add the `hidden` attribute to don't show the placeholder option in the options overlay.
     * ### Example usage
     * ```html
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     * ```
     * ### Note
     * - We did not find a way to detect when the select is reset, if you want to apply the placeholder style when the
     * select is reset, you have to call the `updateStyles()` method manually.
     * - It is strongly recommended to use native-select when you don't have to support the multi-selection feature
     * - Use a native-select instead of a wcs-select if your application is mainly on mobile / tablet. The native behavior of the device will be used.
     */
    interface WcsNativeSelect {
        /**
          * The `size` property controls the size of the slotted `select` element by adjusting its padding. There are two possible size options: - 'm': medium size - 'l': large size  The default value is 'm'.
         */
        "size": WcsNativeSelectSize;
        /**
          * Use this method to force the component to update its styles. It can be useful when the select is reset (with a placeholder).
         */
        "updateStyles": () => Promise<void>;
    }
    /**
     * The nav component is a container for navigation links to other pages of the website.
     */
    interface WcsNav {
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * The nav-item component is a subcomponent of `wcs-nav` and should always be used inside it.  
     * They contain links to navigate to other pages of the website.
     */
    interface WcsNavItem {
    }
    /**
     * The progress-bar component is a horizontal bar that indicates the current completion of a task.
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-bar depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-bar is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-bar in a card, stepper, ...)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-bar is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-bar.
     * >   - **Set the `showLabel` property to `true`** to show the percentage above the progress-bar.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     * @cssprop --wcs-progress-bar-border-radius - Border radius
     * @cssprop --wcs-progress-bar-border-radius-small - Border radius for size small
     * @cssprop --wcs-progress-bar-animation-duration - Animation duration
     */
    interface WcsProgressBar {
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel": boolean;
        /**
          * Specify the size of the progress bar. m = default, s = smaller
         */
        "size": Extract<WcsSize, 'm' | 's'>;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value": number;
    }
    /**
     * The progress-radial component is a circular progress bar that indicates the current completion of a task. 
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-radial depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-radial is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-radial in a card)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-radial is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-radial.
     * >   - **Set the `showLabel` property to `true`** to show the percentage inside the progress-radial.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     */
    interface WcsProgressRadial {
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Whether the component should display the % label inside
         */
        "showLabel": boolean;
        /**
          * The size of the progress radial (in px)
         */
        "size": number;
        /**
          * The value of the progress radial. Prefer values between 0 and 100.
         */
        "value": number;
    }
    /**
     * The radio component should always be wrapped in a `wcs-radio-group`.
     */
    interface WcsRadio {
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled": boolean;
        /**
          * The label text displayed for the user
         */
        "label": string;
        /**
          * The display mode of the control, automatically set by the radio group.   (You shouldn't set this prop by yourself)
         */
        "mode": RadioGroupMode;
        /**
          * The name of the control, automatically set by the radio group.   (You shouldn't set this prop by yourself)
         */
        "name": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        "setTabIndex": (value: number) => Promise<void>;
        "updateState": () => Promise<void>;
        /**
          * Sets a unique value for each radio, used to identify which radio button in a group is selected
         */
        "value": any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        /**
          * The display mode of the control to be set on all radio button children
         */
        "mode": RadioGroupMode;
        /**
          * The name of the control to be set on all radio button children
         */
        "name": any;
        /**
          * The value of the radio-group. Automatically reflects which radio button is selected.
         */
        "value": any | any[] | undefined | null;
    }
    /**
     * The select component (also named combobox) is a form component that allows users to select one or more options
     * from a list.
     * Use it with several slotted `wcs-select-option` inside.
     */
    interface WcsSelect {
        /**
          * If `true`, the select acts as an autocomplete field to filter your results.
         */
        "autocomplete": boolean;
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips": boolean;
        /**
          * Close the component.
         */
        "close": () => Promise<void>;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled": boolean;
        /**
          * Customizable sort function to change the comparison of values. If not provided, uses the default behavior : `option.textContent.toLowerCase().startsWith(filter.toLowerCase())`
         */
        "filterFn": WcsSelectFilterFn;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple": boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Open the component.
         */
        "open": () => Promise<void>;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Specify the size (height) of the select.
         */
        "size": WcsSelectSize;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    /**
     * The select option is a subcomponent of `wcs-select` that represents a single option in a select list.
     */
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Whether this option can be selected.
         */
        "disabled": boolean;
        /**
          * This property mustn't be set by hand, it is used by the `wcs-select` component. Applies a highlight design on the option for autocomplete mode.
          * @ignore
         */
        "highlighted": boolean;
        /**
          * This property mustn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple": boolean;
        /**
          * Whether this option is selected.
         */
        "selected": boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface WcsSkeletonCircle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the radius of the circle in px
         */
        "radius": number;
    }
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface WcsSkeletonRectangle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the height of the skeleton (can be any valid CSS value)
         */
        "height": CssTypes.Height;
        /**
          * Adds a border radius on the skeleton if true
         */
        "rounded": boolean;
        /**
          * Specifies the width of the skeleton (can be any valid CSS value)
         */
        "width": CssTypes.Width;
    }
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface WcsSkeletonText {
        /**
          * Specifies the animation of the skeleton
         */
        "animation": WcsSkeletonAnimation;
        /**
          * Specifies the line height of the text skeleton
         */
        "height": 'h1' | 'h2' | 'h3' | 'caption' | 'body';
    }
    /**
     * The spinner component is visual indicator that showing a process is happening in the background but the interface is
     * not yet ready for interaction.  
     * If your page structure is simple or the loading time is long (> 300ms), use [wcs-skeleton](.?path=/docs/components-skeleton--documentation) instead.
     */
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode": WcsSpinnerMode;
    }
    /**
     * The switch component is a control used to switch between on and off state.
     */
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked": boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled": boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment": SwitchLabelAlignment;
        "name": string;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header": string;
        /**
          * The id of the tab. It should be unique.
         */
        "itemKey": any;
    }
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     * @cssprop --wcs-tabs-width - Width of each tab
     * @cssprop --wcs-tabs-padding-horizontal - Width of each tab
     * @cssprop --wcs-tabs-padding-vertical - Vertical padding
     */
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align": WcsTabsAlignment;
        /**
          * Description is used to provide aria-label for the tabs container which has `role="tablist"`.
         */
        "description": string;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter": boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly": boolean;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex": number;
        "selectedKey": any;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
    }
    /**
     * Mainly inspired from Ionic Textarea Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-textarea outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     * @cssprop --wcs-textarea-padding-left - Padding left of the text area. Take in consideration the transparent border of 2px around the textarea.
     * @cssprop --wcs-textarea-padding-right - Padding right of the text area. Take in consideration the transparent border of 2px around the textarea.
     */
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow": boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize": string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.   Note : at the moment, modifying the width is only possible if you add some custom CSS to the component, for example by overriding the `width` CSS property. See the Resize section for an example on how to do it.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsInput` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce": number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * A hint to the browser for which enter key to display.
         */
        "enterkeyhint"?: WcsTextareaEnterKeyHint;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents": boolean;
        /**
          * This method make the textarea automatically adopt the size of the content without a scroll bar
         */
        "fitContent": () => Promise<void>;
        /**
          * Returns the native `<textarea>` element used under the hood.
         */
        "getInputElement": () => Promise<HTMLTextAreaElement>;
        /**
          * Name of the material icon to add to the input
         */
        "icon": string;
        /**
          * A hint to the browser for which keyboard to display.
         */
        "inputmode"?: WcsTextareaInputMode;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly": boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required": boolean;
        /**
          * Indicates how the textarea should be resizable.   Note : at the moment horizontal resizing is only possible if you add custom CSS to the component, see the Resize section for an example.
         */
        "resize"?: WcsTextareaResize;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        "setAriaAttribute": (attr: AriaAttributeName, value: string | null | undefined) => Promise<void>;
        /**
          * Sets blur on the native `textarea` in `wcs-textarea`. Use this method instead of the global `textarea.blur()`.
         */
        "setBlur": () => Promise<void>;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state": WcsTextareaInputState;
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: WcsTextareaWrap;
    }
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     * ## Accessibility guidelines 💡
     * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve
     * this problem, the tooltip should be served with some aria attributes to make it accessible.
     * Aria-features `wcs-tooltip` respect:
     * - dismiss when the user presses the `Escape` key
     * - has a `role=tooltip`
     * But you have to provide the "link" between the element you want to describe and the tooltip. To do this, you have to
     * provide the "visual description" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available 
     * of the element you want to describe .
     * Example:
     * ```html
     * <wcs-tooltip>Trashed items</wcs-tooltip>
     * <wcs-button aria-label="Trashed items">Trash</wcs-button>
     * ```
     */
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo": WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content": string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay": number | [number, number];
        /**
          * Temporarily prevent the tooltip from showing or hiding
         */
        "disable": () => Promise<void>;
        /**
          * Duration in ms of the transition animation.
         */
        "duration": number | [number, number];
        /**
          * Re-enable a disabled tooltip
         */
        "enable": () => Promise<void>;
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for": string;
        /**
          * Programmatically hide the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive": boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.  To test it on WCS documentation page, add 'px' to the control value (string type in this case).
         */
        "maxWidth": string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position": WcsTooltipPosition;
        /**
          * Programmatically show the tooltip
         */
        "show": () => Promise<void>;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme": string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger": string;
    }
}
export interface WcsAccordionPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsAccordionPanelElement;
}
export interface WcsCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsCheckboxElement;
}
export interface WcsComNavCategoryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavCategoryElement;
}
export interface WcsComNavSubmenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsComNavSubmenuElement;
}
export interface WcsCounterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsCounterElement;
}
export interface WcsDropdownItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsDropdownItemElement;
}
export interface WcsEditableFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsEditableFieldElement;
}
export interface WcsGridCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridElement;
}
export interface WcsGridColumnCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridColumnElement;
}
export interface WcsGridPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsGridPaginationElement;
}
export interface WcsHorizontalStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsHorizontalStepperElement;
}
export interface WcsInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsInputElement;
}
export interface WcsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsModalElement;
}
export interface WcsRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioElement;
}
export interface WcsRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsRadioGroupElement;
}
export interface WcsSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectElement;
}
export interface WcsSelectOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSelectOptionElement;
}
export interface WcsSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsSwitchElement;
}
export interface WcsTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabElement;
}
export interface WcsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTabsElement;
}
export interface WcsTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWcsTextareaElement;
}
declare global {
    /**
     * The accordion component is a vertical stack of interactive headings used to toggle the display of further information.
     */
    interface HTMLWcsAccordionElement extends Components.WcsAccordion, HTMLStencilElement {
    }
    var HTMLWcsAccordionElement: {
        prototype: HTMLWcsAccordionElement;
        new (): HTMLWcsAccordionElement;
    };
    /**
     * The accordion-content is a subcomponent of `wcs-accordion`. It represents the text / content below an expanded accordion.
     */
    interface HTMLWcsAccordionContentElement extends Components.WcsAccordionContent, HTMLStencilElement {
    }
    var HTMLWcsAccordionContentElement: {
        prototype: HTMLWcsAccordionContentElement;
        new (): HTMLWcsAccordionContentElement;
    };
    /**
     * The accordion-header is a subcomponent of `wcs-accordion`. It represents the heading text inside the accordion panel.
     */
    interface HTMLWcsAccordionHeaderElement extends Components.WcsAccordionHeader, HTMLStencilElement {
    }
    var HTMLWcsAccordionHeaderElement: {
        prototype: HTMLWcsAccordionHeaderElement;
        new (): HTMLWcsAccordionHeaderElement;
    };
    interface HTMLWcsAccordionPanelElementEventMap {
        "wcsOpenChange": boolean;
    }
    /**
     * The accordion-panel is a subcomponent of `wcs-accordion`. It represents every panel of the accordion that can be expanded.
     */
    interface HTMLWcsAccordionPanelElement extends Components.WcsAccordionPanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsAccordionPanelElementEventMap>(type: K, listener: (this: HTMLWcsAccordionPanelElement, ev: WcsAccordionPanelCustomEvent<HTMLWcsAccordionPanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsAccordionPanelElementEventMap>(type: K, listener: (this: HTMLWcsAccordionPanelElement, ev: WcsAccordionPanelCustomEvent<HTMLWcsAccordionPanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsAccordionPanelElement: {
        prototype: HTMLWcsAccordionPanelElement;
        new (): HTMLWcsAccordionPanelElement;
    };
    /**
     * The action-bar component is a group of elements appearing across the top of all pages on a business application.
     */
    interface HTMLWcsActionBarElement extends Components.WcsActionBar, HTMLStencilElement {
    }
    var HTMLWcsActionBarElement: {
        prototype: HTMLWcsActionBarElement;
        new (): HTMLWcsActionBarElement;
    };
    interface HTMLWcsAppElement extends Components.WcsApp, HTMLStencilElement {
    }
    var HTMLWcsAppElement: {
        prototype: HTMLWcsAppElement;
        new (): HTMLWcsAppElement;
    };
    /**
     * The badge component is a small label, generally appearing inside or in proximity to another larger interface component,
     * representing a status, property, or some other metadata.
     * @cssprop --wcs-badge-ligther-percentage - Define the opacity rate to apply to the badge
     */
    interface HTMLWcsBadgeElement extends Components.WcsBadge, HTMLStencilElement {
    }
    var HTMLWcsBadgeElement: {
        prototype: HTMLWcsBadgeElement;
        new (): HTMLWcsBadgeElement;
    };
    /**
     * A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order.  
     * It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.  
     * ## Accessibility guidelines 💡
     * > If the last item is a link to the current page, you must set the `aria-current` attribute to `page`.  
     * > If the element representing the current page is not a link, aria-current is optional.
     */
    interface HTMLWcsBreadcrumbElement extends Components.WcsBreadcrumb, HTMLStencilElement {
    }
    var HTMLWcsBreadcrumbElement: {
        prototype: HTMLWcsBreadcrumbElement;
        new (): HTMLWcsBreadcrumbElement;
    };
    interface HTMLWcsBreadcrumbItemElement extends Components.WcsBreadcrumbItem, HTMLStencilElement {
    }
    var HTMLWcsBreadcrumbItemElement: {
        prototype: HTMLWcsBreadcrumbItemElement;
        new (): HTMLWcsBreadcrumbItemElement;
    };
    /**
     * The button component is used to trigger an action. It can also be a link when specifying href.
     * ## Accessibility guidelines 💡
     * > If your button doesn't contain text but only an image, you must set a relevant aria-label on the icon 👉 [see "Square" story below](#square)
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface HTMLWcsButtonElement extends Components.WcsButton, HTMLStencilElement {
    }
    var HTMLWcsButtonElement: {
        prototype: HTMLWcsButtonElement;
        new (): HTMLWcsButtonElement;
    };
    /**
     * The card component is a container that display content such as text, images, buttons, and lists.  
     * A card can be a single component, but is often made up of a header, title, subtitle, and content.
     */
    interface HTMLWcsCardElement extends Components.WcsCard, HTMLStencilElement {
    }
    var HTMLWcsCardElement: {
        prototype: HTMLWcsCardElement;
        new (): HTMLWcsCardElement;
    };
    /**
     * The card-body is a subcomponent of `wcs-card`. It represents content of the card with an extra padding around.
     */
    interface HTMLWcsCardBodyElement extends Components.WcsCardBody, HTMLStencilElement {
    }
    var HTMLWcsCardBodyElement: {
        prototype: HTMLWcsCardBodyElement;
        new (): HTMLWcsCardBodyElement;
    };
    interface HTMLWcsCheckboxElementEventMap {
        "wcsChange": CheckboxChangeEventDetail;
        "wcsFocus": FocusEvent;
        "wcsBlur": FocusEvent;
    }
    /**
     * The checkbox component is an input for choosing one or more items from a set by checking / unchecking it.
     */
    interface HTMLWcsCheckboxElement extends Components.WcsCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsCheckboxElementEventMap>(type: K, listener: (this: HTMLWcsCheckboxElement, ev: WcsCheckboxCustomEvent<HTMLWcsCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsCheckboxElementEventMap>(type: K, listener: (this: HTMLWcsCheckboxElement, ev: WcsCheckboxCustomEvent<HTMLWcsCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsCheckboxElement: {
        prototype: HTMLWcsCheckboxElement;
        new (): HTMLWcsCheckboxElement;
    };
    /**
     * *Part of communication design system*
     * The com-nav component is a container for navigation links to external or internal pages of the website.
     */
    interface HTMLWcsComNavElement extends Components.WcsComNav, HTMLStencilElement {
    }
    var HTMLWcsComNavElement: {
        prototype: HTMLWcsComNavElement;
        new (): HTMLWcsComNavElement;
    };
    interface HTMLWcsComNavCategoryElementEventMap {
        "wcsCategoryOpened": CategoryOpenedEventDetail;
        "wcsCategoryItemClicked": UIEvent;
    }
    /**
     * The com-nav-category is a subcomponent of `wcs-com-nav`. It represents a category nested inside a `wcs-com-nav-submenu`.
     */
    interface HTMLWcsComNavCategoryElement extends Components.WcsComNavCategory, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsComNavCategoryElementEventMap>(type: K, listener: (this: HTMLWcsComNavCategoryElement, ev: WcsComNavCategoryCustomEvent<HTMLWcsComNavCategoryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsComNavCategoryElementEventMap>(type: K, listener: (this: HTMLWcsComNavCategoryElement, ev: WcsComNavCategoryCustomEvent<HTMLWcsComNavCategoryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsComNavCategoryElement: {
        prototype: HTMLWcsComNavCategoryElement;
        new (): HTMLWcsComNavCategoryElement;
    };
    /**
     * The com-nav-item is a subcomponent of `wcs-com-nav`. It represents a list-item wrapper around a link.
     */
    interface HTMLWcsComNavItemElement extends Components.WcsComNavItem, HTMLStencilElement {
    }
    var HTMLWcsComNavItemElement: {
        prototype: HTMLWcsComNavItemElement;
        new (): HTMLWcsComNavItemElement;
    };
    interface HTMLWcsComNavSubmenuElementEventMap {
        "wcsSubmenuOpened": MenuOpenedEventDetail;
        "wcsClickOnFinalAction": void;
    }
    /**
     * The com-nav-submenu is a subcomponent of `wcs-com-nav`. It represents an expandable menu containing more items or categories.
     */
    interface HTMLWcsComNavSubmenuElement extends Components.WcsComNavSubmenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsComNavSubmenuElementEventMap>(type: K, listener: (this: HTMLWcsComNavSubmenuElement, ev: WcsComNavSubmenuCustomEvent<HTMLWcsComNavSubmenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsComNavSubmenuElementEventMap>(type: K, listener: (this: HTMLWcsComNavSubmenuElement, ev: WcsComNavSubmenuCustomEvent<HTMLWcsComNavSubmenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsComNavSubmenuElement: {
        prototype: HTMLWcsComNavSubmenuElement;
        new (): HTMLWcsComNavSubmenuElement;
    };
    interface HTMLWcsCounterElementEventMap {
        "wcsChange": CounterChangeEventDetail;
        "wcsBlur": FocusEvent;
    }
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface HTMLWcsCounterElement extends Components.WcsCounter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsCounterElementEventMap>(type: K, listener: (this: HTMLWcsCounterElement, ev: WcsCounterCustomEvent<HTMLWcsCounterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsCounterElementEventMap>(type: K, listener: (this: HTMLWcsCounterElement, ev: WcsCounterCustomEvent<HTMLWcsCounterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsCounterElement: {
        prototype: HTMLWcsCounterElement;
        new (): HTMLWcsCounterElement;
    };
    interface HTMLWcsDividerElement extends Components.WcsDivider, HTMLStencilElement {
    }
    var HTMLWcsDividerElement: {
        prototype: HTMLWcsDividerElement;
        new (): HTMLWcsDividerElement;
    };
    /**
     * The dropdown component use a wcs-button under the hood, so you can use the same css classes as the button to style the
     * dropdown.
     */
    interface HTMLWcsDropdownElement extends Components.WcsDropdown, HTMLStencilElement {
    }
    var HTMLWcsDropdownElement: {
        prototype: HTMLWcsDropdownElement;
        new (): HTMLWcsDropdownElement;
    };
    /**
     * You can add a divider between groups of items
     */
    interface HTMLWcsDropdownDividerElement extends Components.WcsDropdownDivider, HTMLStencilElement {
    }
    var HTMLWcsDropdownDividerElement: {
        prototype: HTMLWcsDropdownDividerElement;
        new (): HTMLWcsDropdownDividerElement;
    };
    /**
     * You can add `wcs-dropdown-header` before a group of items to describe it
     */
    interface HTMLWcsDropdownHeaderElement extends Components.WcsDropdownHeader, HTMLStencilElement {
    }
    var HTMLWcsDropdownHeaderElement: {
        prototype: HTMLWcsDropdownHeaderElement;
        new (): HTMLWcsDropdownHeaderElement;
    };
    interface HTMLWcsDropdownItemElementEventMap {
        "wcsDropdownItemClick": void;
    }
    /**
     * You must add `wcs-dropdown-item` to `wcs-dropdown`
     */
    interface HTMLWcsDropdownItemElement extends Components.WcsDropdownItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsDropdownItemElementEventMap>(type: K, listener: (this: HTMLWcsDropdownItemElement, ev: WcsDropdownItemCustomEvent<HTMLWcsDropdownItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsDropdownItemElementEventMap>(type: K, listener: (this: HTMLWcsDropdownItemElement, ev: WcsDropdownItemCustomEvent<HTMLWcsDropdownItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsDropdownItemElement: {
        prototype: HTMLWcsDropdownItemElement;
        new (): HTMLWcsDropdownItemElement;
    };
    interface HTMLWcsEditableFieldElementEventMap {
        "wcsChange": EditableComponentUpdateEvent;
    }
    /**
     * The editable-field component can be used to simplify the user experience, avoiding the use of a redirection to a form
     * to edit the data of an entity. You can use it with these wrapped components : `wcs-input`, `wcs-textarea`, `wcs-select`. 
     * This component is not present in the SNCF design system specifications, so we tried to build it in the most
     * "discoverable" way possible (for users who interact with), but it's a first version.
     * **How to use ❓**  
     * This component is mostly used with a server that returns a response to the input sent through the `wcsChange` event.
     * It has 3 internal states :
     * - DISPLAY = the default state of the editable-field
     * - EDIT = the editable-field is editable, the user should input the data
     * - LOADING = the data is submitted and the editable-field is waiting for a **response**
     * A **response** is needed to get the component out of the LOADING state. You can either :
     * - Set the `value` property to a different value to tell the component to refresh and go back into DISPLAY state
     * - Use the `successHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * - Use the `errorHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * **Accessibility guidelines 💡**  
     * > - Aria attributes are put on the native component on the first rendering with the `label` and `errorMsg` you provided 
     * > - Additional aria attributes put on `<wcs-editable-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface HTMLWcsEditableFieldElement extends Components.WcsEditableField, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsEditableFieldElementEventMap>(type: K, listener: (this: HTMLWcsEditableFieldElement, ev: WcsEditableFieldCustomEvent<HTMLWcsEditableFieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsEditableFieldElementEventMap>(type: K, listener: (this: HTMLWcsEditableFieldElement, ev: WcsEditableFieldCustomEvent<HTMLWcsEditableFieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsEditableFieldElement: {
        prototype: HTMLWcsEditableFieldElement;
        new (): HTMLWcsEditableFieldElement;
    };
    /**
     * The `wcs-error` should always be wrapped in a `wcs-form-field`.
     * It is used to display a red message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant error message to inform the users what they should change to make the field valid
     * - `aria-description` will be automatically added to the field for screen readers
     * - `aria-invalid="true"` will be automatically added to the field for screen readers
     */
    interface HTMLWcsErrorElement extends Components.WcsError, HTMLStencilElement {
    }
    var HTMLWcsErrorElement: {
        prototype: HTMLWcsErrorElement;
        new (): HTMLWcsErrorElement;
    };
    /**
     * This field component can be used to display the details of an entity. It is built around the label and the content of the field.
     */
    interface HTMLWcsFieldElement extends Components.WcsField, HTMLStencilElement {
    }
    var HTMLWcsFieldElement: {
        prototype: HTMLWcsFieldElement;
        new (): HTMLWcsFieldElement;
    };
    /**
     * The field-content is a subcomponent of `wcs-field`. It represents the text content of the field.
     */
    interface HTMLWcsFieldContentElement extends Components.WcsFieldContent, HTMLStencilElement {
    }
    var HTMLWcsFieldContentElement: {
        prototype: HTMLWcsFieldContentElement;
        new (): HTMLWcsFieldContentElement;
    };
    /**
     * The field-label is a subcomponent of `wcs-field`. It represents the label or title of the field.
     */
    interface HTMLWcsFieldLabelElement extends Components.WcsFieldLabel, HTMLStencilElement {
    }
    var HTMLWcsFieldLabelElement: {
        prototype: HTMLWcsFieldLabelElement;
        new (): HTMLWcsFieldLabelElement;
    };
    /**
     * The footer component has been designed to leave as much customization as possible to the developer. The footers are often specific to the application developed.
     */
    interface HTMLWcsFooterElement extends Components.WcsFooter, HTMLStencilElement {
    }
    var HTMLWcsFooterElement: {
        prototype: HTMLWcsFooterElement;
        new (): HTMLWcsFooterElement;
    };
    /**
     * Form field component wraps the native input element and add some more functionality on top of it.
     * You can use the `wcs-form-field` to wrap any of these components :
     * - `wcs-input`
     * - `wcs-textarea`
     * - `wcs-radio-group`
     * - `wcs-switch`
     * - `wcs-checkbox`
     * - `wcs-native-select`
     * - `wcs-select`
     * - `wcs-counter`
     * For non-supported slotted component, you can use the `required` attribute on the wrapped component to tell the
     * form-field that it is required. It will add a red star after the label of the form field.
     * ## Accessibility guidelines 💡
     * - Each form control should be identified with a unique `wcs-label`
     * - Don't forget to add form validation to make sure the data is correctly formatted
     * - If the `wcs-label` is required, the form control must have the `required` HTML attribute and vice-versa (this is normally automatically set)
     * - The form should not be submittable if at least one required form control is not filled
     * - Hints are optional and should only be used to add extra information
     * - Additional aria attributes put on `<wcs-form-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface HTMLWcsFormFieldElement extends Components.WcsFormField, HTMLStencilElement {
    }
    var HTMLWcsFormFieldElement: {
        prototype: HTMLWcsFormFieldElement;
        new (): HTMLWcsFormFieldElement;
    };
    interface HTMLWcsGalacticElement extends Components.WcsGalactic, HTMLStencilElement {
    }
    var HTMLWcsGalacticElement: {
        prototype: HTMLWcsGalacticElement;
        new (): HTMLWcsGalacticElement;
    };
    interface HTMLWcsGalacticMenuElement extends Components.WcsGalacticMenu, HTMLStencilElement {
    }
    var HTMLWcsGalacticMenuElement: {
        prototype: HTMLWcsGalacticMenuElement;
        new (): HTMLWcsGalacticMenuElement;
    };
    interface HTMLWcsGridElementEventMap {
        "wcsGridSelectionChange": WcsGridSelectionEventDetails;
        "wcsGridAllSelectionChange": WcsGridAllRowSelectedEventDetails;
        "wcsFocus": FocusEvent;
        "wcsBlur": FocusEvent;
    }
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface HTMLWcsGridElement extends Components.WcsGrid, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsGridElementEventMap>(type: K, listener: (this: HTMLWcsGridElement, ev: WcsGridCustomEvent<HTMLWcsGridElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsGridElementEventMap>(type: K, listener: (this: HTMLWcsGridElement, ev: WcsGridCustomEvent<HTMLWcsGridElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsGridElement: {
        prototype: HTMLWcsGridElement;
        new (): HTMLWcsGridElement;
    };
    interface HTMLWcsGridColumnElementEventMap {
        "wcsSortChange": WcsGridColumnSortChangeEventDetails;
        "wcsHiddenChange": boolean;
    }
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface HTMLWcsGridColumnElement extends Components.WcsGridColumn, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsGridColumnElementEventMap>(type: K, listener: (this: HTMLWcsGridColumnElement, ev: WcsGridColumnCustomEvent<HTMLWcsGridColumnElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsGridColumnElementEventMap>(type: K, listener: (this: HTMLWcsGridColumnElement, ev: WcsGridColumnCustomEvent<HTMLWcsGridColumnElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsGridColumnElement: {
        prototype: HTMLWcsGridColumnElement;
        new (): HTMLWcsGridColumnElement;
    };
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface HTMLWcsGridCustomCellElement extends Components.WcsGridCustomCell, HTMLStencilElement {
    }
    var HTMLWcsGridCustomCellElement: {
        prototype: HTMLWcsGridCustomCellElement;
        new (): HTMLWcsGridCustomCellElement;
    };
    interface HTMLWcsGridPaginationElementEventMap {
        "wcsGridPaginationChange": WcsGridPaginationChangeEventDetails;
    }
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface HTMLWcsGridPaginationElement extends Components.WcsGridPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsGridPaginationElementEventMap>(type: K, listener: (this: HTMLWcsGridPaginationElement, ev: WcsGridPaginationCustomEvent<HTMLWcsGridPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsGridPaginationElementEventMap>(type: K, listener: (this: HTMLWcsGridPaginationElement, ev: WcsGridPaginationCustomEvent<HTMLWcsGridPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsGridPaginationElement: {
        prototype: HTMLWcsGridPaginationElement;
        new (): HTMLWcsGridPaginationElement;
    };
    /**
     * The header component is an element that appears across the top of all pages on a website or application; it contains the logo, the site name and main actions.
     */
    interface HTMLWcsHeaderElement extends Components.WcsHeader, HTMLStencilElement {
    }
    var HTMLWcsHeaderElement: {
        prototype: HTMLWcsHeaderElement;
        new (): HTMLWcsHeaderElement;
    };
    /**
     * The `wcs-hint` should always be wrapped in a `wcs-form-field`.
     * It is used to display an informative message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant hint message to inform the users about the format, how the data should be filled in, or what is the purpose of the field
     * - `aria-description` will be automatically added to the field for screen readers
     */
    interface HTMLWcsHintElement extends Components.WcsHint, HTMLStencilElement {
    }
    var HTMLWcsHintElement: {
        prototype: HTMLWcsHintElement;
        new (): HTMLWcsHintElement;
    };
    interface HTMLWcsHorizontalStepperElementEventMap {
        "wcsHorizontalStepClick": HorizontalStepClickEvent;
    }
    /**
     * The horizontal-stepper is a representation of a user’s progress through a series of discrete steps.
     */
    interface HTMLWcsHorizontalStepperElement extends Components.WcsHorizontalStepper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsHorizontalStepperElementEventMap>(type: K, listener: (this: HTMLWcsHorizontalStepperElement, ev: WcsHorizontalStepperCustomEvent<HTMLWcsHorizontalStepperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsHorizontalStepperElementEventMap>(type: K, listener: (this: HTMLWcsHorizontalStepperElement, ev: WcsHorizontalStepperCustomEvent<HTMLWcsHorizontalStepperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsHorizontalStepperElement: {
        prototype: HTMLWcsHorizontalStepperElement;
        new (): HTMLWcsHorizontalStepperElement;
    };
    /**
     * The icon component is a graphic symbol designed to visually indicate the purpose of an interface element.
     */
    interface HTMLWcsIconElement extends Components.WcsIcon, HTMLStencilElement {
    }
    var HTMLWcsIconElement: {
        prototype: HTMLWcsIconElement;
        new (): HTMLWcsIconElement;
    };
    interface HTMLWcsInputElementEventMap {
        "wcsInput": KeyboardEvent;
        "wcsChange": InputChangeEventDetail;
        "wcsBlur": FocusEvent;
        "wcsFocus": FocusEvent;
    }
    /**
     * The input component is a form control that accepts a single line of text.
     * Implementation mainly inspired from Ionic Input Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-input outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     */
    interface HTMLWcsInputElement extends Components.WcsInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsInputElementEventMap>(type: K, listener: (this: HTMLWcsInputElement, ev: WcsInputCustomEvent<HTMLWcsInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsInputElementEventMap>(type: K, listener: (this: HTMLWcsInputElement, ev: WcsInputCustomEvent<HTMLWcsInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsInputElement: {
        prototype: HTMLWcsInputElement;
        new (): HTMLWcsInputElement;
    };
    /**
     * The `wcs-label` should always be wrapped in a `wcs-form-field`.
     * It is used to caption a form control component.
     * ## Accessibility guidelines 💡
     * - Use concise name for the label. If you want to describe more your form control, add a `wcs-hint`
     * - Use the required flag only as an indication to inform users that the form control is required
     */
    interface HTMLWcsLabelElement extends Components.WcsLabel, HTMLStencilElement {
    }
    var HTMLWcsLabelElement: {
        prototype: HTMLWcsLabelElement;
        new (): HTMLWcsLabelElement;
    };
    /**
     * Lists are used for grouping a collection of related items.
     * Standard lists can be used either with or without icons. Depending on the context, the list can have one or more
     * actions (favourite, download, delete, etc.). Use standard lists with a unique action when each line has an action.
     */
    interface HTMLWcsListItemElement extends Components.WcsListItem, HTMLStencilElement {
    }
    var HTMLWcsListItemElement: {
        prototype: HTMLWcsListItemElement;
        new (): HTMLWcsListItemElement;
    };
    /**
     * The list-item-properties is a subcomponent of `wcs-list-item`. It represents a wrapper for a list of several `wcs-property`.
     */
    interface HTMLWcsListItemPropertiesElement extends Components.WcsListItemProperties, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertiesElement: {
        prototype: HTMLWcsListItemPropertiesElement;
        new (): HTMLWcsListItemPropertiesElement;
    };
    /**
     * The list-item-property is a subcomponent of `wcs-list-item`.
     * Wrapped in a `wcs-list-item-properties`, it represents a property to describe an item.
     */
    interface HTMLWcsListItemPropertyElement extends Components.WcsListItemProperty, HTMLStencilElement {
    }
    var HTMLWcsListItemPropertyElement: {
        prototype: HTMLWcsListItemPropertyElement;
        new (): HTMLWcsListItemPropertyElement;
    };
    /**
     * A component used to display a [Material Icon](https://fonts.google.com/icons). Can be useful when used in wcs-grid or in a wcs-button.
     */
    interface HTMLWcsMatIconElement extends Components.WcsMatIcon, HTMLStencilElement {
    }
    var HTMLWcsMatIconElement: {
        prototype: HTMLWcsMatIconElement;
        new (): HTMLWcsMatIconElement;
    };
    interface HTMLWcsModalElementEventMap {
        "wcsDialogClosed": void;
    }
    /**
     * The modal component (also named dialog or popup) is an interface element that appears on top of the page content.
     * Use it to show a message, a confirmation dialog, or any other content like forms.
     * ## Accessibility guidelines 💡
     * > - Modal element has `role="dialog"` and `aria-modal="true"`
     * > - Keyboard navigation is trapped inside the modal
     * > - It is mandatory to set the `modal-trigger-controls-id` to the id of the element that opens the dialog, in order
     * > to focus it upon dialog dismissal.
     * > - The modal can be closed at any time by pressing the Escape key.
     * >
     * > - More info : https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/
     * @cssprop --wcs-modal-max-height - Max height of the main container
     * @cssprop --wcs-modal-overflow-y - Overflow-y of the content
     */
    interface HTMLWcsModalElement extends Components.WcsModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsModalElementEventMap>(type: K, listener: (this: HTMLWcsModalElement, ev: WcsModalCustomEvent<HTMLWcsModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsModalElementEventMap>(type: K, listener: (this: HTMLWcsModalElement, ev: WcsModalCustomEvent<HTMLWcsModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsModalElement: {
        prototype: HTMLWcsModalElement;
        new (): HTMLWcsModalElement;
    };
    /**
     * The `wcs-native-select` component is designed to accept a native `<select>` element as a slotted child. This choice
     * allows developers to bind the `<select>` element using the framework of their choice, without the need to re-expose all the
     * properties of the `<select>` and `<option>` elements in this component.
     * The component wraps the native `<select>` element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * ### ✅ Guidance
     * - To have a placeholder, you must have an option as child which has `selected` attribute and `disabled`
     * attribute. You can add the `hidden` attribute to don't show the placeholder option in the options overlay.
     * ### Example usage
     * ```html
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     * ```
     * ### Note
     * - We did not find a way to detect when the select is reset, if you want to apply the placeholder style when the
     * select is reset, you have to call the `updateStyles()` method manually.
     * - It is strongly recommended to use native-select when you don't have to support the multi-selection feature
     * - Use a native-select instead of a wcs-select if your application is mainly on mobile / tablet. The native behavior of the device will be used.
     */
    interface HTMLWcsNativeSelectElement extends Components.WcsNativeSelect, HTMLStencilElement {
    }
    var HTMLWcsNativeSelectElement: {
        prototype: HTMLWcsNativeSelectElement;
        new (): HTMLWcsNativeSelectElement;
    };
    /**
     * The nav component is a container for navigation links to other pages of the website.
     */
    interface HTMLWcsNavElement extends Components.WcsNav, HTMLStencilElement {
    }
    var HTMLWcsNavElement: {
        prototype: HTMLWcsNavElement;
        new (): HTMLWcsNavElement;
    };
    /**
     * The nav-item component is a subcomponent of `wcs-nav` and should always be used inside it.  
     * They contain links to navigate to other pages of the website.
     */
    interface HTMLWcsNavItemElement extends Components.WcsNavItem, HTMLStencilElement {
    }
    var HTMLWcsNavItemElement: {
        prototype: HTMLWcsNavItemElement;
        new (): HTMLWcsNavItemElement;
    };
    /**
     * The progress-bar component is a horizontal bar that indicates the current completion of a task.
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-bar depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-bar is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-bar in a card, stepper, ...)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-bar is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-bar.
     * >   - **Set the `showLabel` property to `true`** to show the percentage above the progress-bar.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     * @cssprop --wcs-progress-bar-border-radius - Border radius
     * @cssprop --wcs-progress-bar-border-radius-small - Border radius for size small
     * @cssprop --wcs-progress-bar-animation-duration - Animation duration
     */
    interface HTMLWcsProgressBarElement extends Components.WcsProgressBar, HTMLStencilElement {
    }
    var HTMLWcsProgressBarElement: {
        prototype: HTMLWcsProgressBarElement;
        new (): HTMLWcsProgressBarElement;
    };
    /**
     * The progress-radial component is a circular progress bar that indicates the current completion of a task. 
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-radial depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-radial is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-radial in a card)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-radial is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-radial.
     * >   - **Set the `showLabel` property to `true`** to show the percentage inside the progress-radial.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     */
    interface HTMLWcsProgressRadialElement extends Components.WcsProgressRadial, HTMLStencilElement {
    }
    var HTMLWcsProgressRadialElement: {
        prototype: HTMLWcsProgressRadialElement;
        new (): HTMLWcsProgressRadialElement;
    };
    interface HTMLWcsRadioElementEventMap {
        "wcsRadioClick": RadioChosedEvent;
        "wcsBlur": FocusEvent;
        "wcsFocus": FocusEvent;
    }
    /**
     * The radio component should always be wrapped in a `wcs-radio-group`.
     */
    interface HTMLWcsRadioElement extends Components.WcsRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsRadioElementEventMap>(type: K, listener: (this: HTMLWcsRadioElement, ev: WcsRadioCustomEvent<HTMLWcsRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsRadioElementEventMap>(type: K, listener: (this: HTMLWcsRadioElement, ev: WcsRadioCustomEvent<HTMLWcsRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsRadioElement: {
        prototype: HTMLWcsRadioElement;
        new (): HTMLWcsRadioElement;
    };
    interface HTMLWcsRadioGroupElementEventMap {
        "wcsChange": RadioGroupChangeEventDetail;
    }
    interface HTMLWcsRadioGroupElement extends Components.WcsRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsRadioGroupElementEventMap>(type: K, listener: (this: HTMLWcsRadioGroupElement, ev: WcsRadioGroupCustomEvent<HTMLWcsRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsRadioGroupElementEventMap>(type: K, listener: (this: HTMLWcsRadioGroupElement, ev: WcsRadioGroupCustomEvent<HTMLWcsRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsRadioGroupElement: {
        prototype: HTMLWcsRadioGroupElement;
        new (): HTMLWcsRadioGroupElement;
    };
    interface HTMLWcsSelectElementEventMap {
        "wcsChange": SelectChangeEventDetail;
        "wcsFocus": FocusEvent;
        "wcsBlur": FocusEvent;
        "wcsFilterChange": SelectFilterChangeEventDetail;
    }
    /**
     * The select component (also named combobox) is a form component that allows users to select one or more options
     * from a list.
     * Use it with several slotted `wcs-select-option` inside.
     */
    interface HTMLWcsSelectElement extends Components.WcsSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsSelectElementEventMap>(type: K, listener: (this: HTMLWcsSelectElement, ev: WcsSelectCustomEvent<HTMLWcsSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsSelectElementEventMap>(type: K, listener: (this: HTMLWcsSelectElement, ev: WcsSelectCustomEvent<HTMLWcsSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsSelectElement: {
        prototype: HTMLWcsSelectElement;
        new (): HTMLWcsSelectElement;
    };
    interface HTMLWcsSelectOptionElementEventMap {
        "wcsSelectOptionClick": SelectOptionChosedEvent;
    }
    /**
     * The select option is a subcomponent of `wcs-select` that represents a single option in a select list.
     */
    interface HTMLWcsSelectOptionElement extends Components.WcsSelectOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsSelectOptionElementEventMap>(type: K, listener: (this: HTMLWcsSelectOptionElement, ev: WcsSelectOptionCustomEvent<HTMLWcsSelectOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsSelectOptionElementEventMap>(type: K, listener: (this: HTMLWcsSelectOptionElement, ev: WcsSelectOptionCustomEvent<HTMLWcsSelectOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsSelectOptionElement: {
        prototype: HTMLWcsSelectOptionElement;
        new (): HTMLWcsSelectOptionElement;
    };
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface HTMLWcsSkeletonCircleElement extends Components.WcsSkeletonCircle, HTMLStencilElement {
    }
    var HTMLWcsSkeletonCircleElement: {
        prototype: HTMLWcsSkeletonCircleElement;
        new (): HTMLWcsSkeletonCircleElement;
    };
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface HTMLWcsSkeletonRectangleElement extends Components.WcsSkeletonRectangle, HTMLStencilElement {
    }
    var HTMLWcsSkeletonRectangleElement: {
        prototype: HTMLWcsSkeletonRectangleElement;
        new (): HTMLWcsSkeletonRectangleElement;
    };
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface HTMLWcsSkeletonTextElement extends Components.WcsSkeletonText, HTMLStencilElement {
    }
    var HTMLWcsSkeletonTextElement: {
        prototype: HTMLWcsSkeletonTextElement;
        new (): HTMLWcsSkeletonTextElement;
    };
    /**
     * The spinner component is visual indicator that showing a process is happening in the background but the interface is
     * not yet ready for interaction.  
     * If your page structure is simple or the loading time is long (> 300ms), use [wcs-skeleton](.?path=/docs/components-skeleton--documentation) instead.
     */
    interface HTMLWcsSpinnerElement extends Components.WcsSpinner, HTMLStencilElement {
    }
    var HTMLWcsSpinnerElement: {
        prototype: HTMLWcsSpinnerElement;
        new (): HTMLWcsSpinnerElement;
    };
    interface HTMLWcsSwitchElementEventMap {
        "wcsChange": SwitchChangeEventDetail;
        "wcsFocus": FocusEvent;
        "wcsBlur": FocusEvent;
    }
    /**
     * The switch component is a control used to switch between on and off state.
     */
    interface HTMLWcsSwitchElement extends Components.WcsSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsSwitchElementEventMap>(type: K, listener: (this: HTMLWcsSwitchElement, ev: WcsSwitchCustomEvent<HTMLWcsSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsSwitchElementEventMap>(type: K, listener: (this: HTMLWcsSwitchElement, ev: WcsSwitchCustomEvent<HTMLWcsSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsSwitchElement: {
        prototype: HTMLWcsSwitchElement;
        new (): HTMLWcsSwitchElement;
    };
    interface HTMLWcsTabElementEventMap {
        "tabLoaded": void;
    }
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface HTMLWcsTabElement extends Components.WcsTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsTabElementEventMap>(type: K, listener: (this: HTMLWcsTabElement, ev: WcsTabCustomEvent<HTMLWcsTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsTabElementEventMap>(type: K, listener: (this: HTMLWcsTabElement, ev: WcsTabCustomEvent<HTMLWcsTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsTabElement: {
        prototype: HTMLWcsTabElement;
        new (): HTMLWcsTabElement;
    };
    interface HTMLWcsTabsElementEventMap {
        "tabChange": WcsTabChangeEvent;
    }
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     * @cssprop --wcs-tabs-width - Width of each tab
     * @cssprop --wcs-tabs-padding-horizontal - Width of each tab
     * @cssprop --wcs-tabs-padding-vertical - Vertical padding
     */
    interface HTMLWcsTabsElement extends Components.WcsTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsTabsElementEventMap>(type: K, listener: (this: HTMLWcsTabsElement, ev: WcsTabsCustomEvent<HTMLWcsTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsTabsElementEventMap>(type: K, listener: (this: HTMLWcsTabsElement, ev: WcsTabsCustomEvent<HTMLWcsTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsTabsElement: {
        prototype: HTMLWcsTabsElement;
        new (): HTMLWcsTabsElement;
    };
    interface HTMLWcsTextareaElementEventMap {
        "wcsChange": TextareaChangeEventDetail;
        "wcsInput": KeyboardEvent;
        "wcsBlur": FocusEvent;
        "wcsFocus": FocusEvent;
    }
    /**
     * Mainly inspired from Ionic Textarea Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-textarea outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     * @cssprop --wcs-textarea-padding-left - Padding left of the text area. Take in consideration the transparent border of 2px around the textarea.
     * @cssprop --wcs-textarea-padding-right - Padding right of the text area. Take in consideration the transparent border of 2px around the textarea.
     */
    interface HTMLWcsTextareaElement extends Components.WcsTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWcsTextareaElementEventMap>(type: K, listener: (this: HTMLWcsTextareaElement, ev: WcsTextareaCustomEvent<HTMLWcsTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWcsTextareaElementEventMap>(type: K, listener: (this: HTMLWcsTextareaElement, ev: WcsTextareaCustomEvent<HTMLWcsTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWcsTextareaElement: {
        prototype: HTMLWcsTextareaElement;
        new (): HTMLWcsTextareaElement;
    };
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     * ## Accessibility guidelines 💡
     * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve
     * this problem, the tooltip should be served with some aria attributes to make it accessible.
     * Aria-features `wcs-tooltip` respect:
     * - dismiss when the user presses the `Escape` key
     * - has a `role=tooltip`
     * But you have to provide the "link" between the element you want to describe and the tooltip. To do this, you have to
     * provide the "visual description" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available 
     * of the element you want to describe .
     * Example:
     * ```html
     * <wcs-tooltip>Trashed items</wcs-tooltip>
     * <wcs-button aria-label="Trashed items">Trash</wcs-button>
     * ```
     */
    interface HTMLWcsTooltipElement extends Components.WcsTooltip, HTMLStencilElement {
    }
    var HTMLWcsTooltipElement: {
        prototype: HTMLWcsTooltipElement;
        new (): HTMLWcsTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "wcs-accordion": HTMLWcsAccordionElement;
        "wcs-accordion-content": HTMLWcsAccordionContentElement;
        "wcs-accordion-header": HTMLWcsAccordionHeaderElement;
        "wcs-accordion-panel": HTMLWcsAccordionPanelElement;
        "wcs-action-bar": HTMLWcsActionBarElement;
        "wcs-app": HTMLWcsAppElement;
        "wcs-badge": HTMLWcsBadgeElement;
        "wcs-breadcrumb": HTMLWcsBreadcrumbElement;
        "wcs-breadcrumb-item": HTMLWcsBreadcrumbItemElement;
        "wcs-button": HTMLWcsButtonElement;
        "wcs-card": HTMLWcsCardElement;
        "wcs-card-body": HTMLWcsCardBodyElement;
        "wcs-checkbox": HTMLWcsCheckboxElement;
        "wcs-com-nav": HTMLWcsComNavElement;
        "wcs-com-nav-category": HTMLWcsComNavCategoryElement;
        "wcs-com-nav-item": HTMLWcsComNavItemElement;
        "wcs-com-nav-submenu": HTMLWcsComNavSubmenuElement;
        "wcs-counter": HTMLWcsCounterElement;
        "wcs-divider": HTMLWcsDividerElement;
        "wcs-dropdown": HTMLWcsDropdownElement;
        "wcs-dropdown-divider": HTMLWcsDropdownDividerElement;
        "wcs-dropdown-header": HTMLWcsDropdownHeaderElement;
        "wcs-dropdown-item": HTMLWcsDropdownItemElement;
        "wcs-editable-field": HTMLWcsEditableFieldElement;
        "wcs-error": HTMLWcsErrorElement;
        "wcs-field": HTMLWcsFieldElement;
        "wcs-field-content": HTMLWcsFieldContentElement;
        "wcs-field-label": HTMLWcsFieldLabelElement;
        "wcs-footer": HTMLWcsFooterElement;
        "wcs-form-field": HTMLWcsFormFieldElement;
        "wcs-galactic": HTMLWcsGalacticElement;
        "wcs-galactic-menu": HTMLWcsGalacticMenuElement;
        "wcs-grid": HTMLWcsGridElement;
        "wcs-grid-column": HTMLWcsGridColumnElement;
        "wcs-grid-custom-cell": HTMLWcsGridCustomCellElement;
        "wcs-grid-pagination": HTMLWcsGridPaginationElement;
        "wcs-header": HTMLWcsHeaderElement;
        "wcs-hint": HTMLWcsHintElement;
        "wcs-horizontal-stepper": HTMLWcsHorizontalStepperElement;
        "wcs-icon": HTMLWcsIconElement;
        "wcs-input": HTMLWcsInputElement;
        "wcs-label": HTMLWcsLabelElement;
        "wcs-list-item": HTMLWcsListItemElement;
        "wcs-list-item-properties": HTMLWcsListItemPropertiesElement;
        "wcs-list-item-property": HTMLWcsListItemPropertyElement;
        "wcs-mat-icon": HTMLWcsMatIconElement;
        "wcs-modal": HTMLWcsModalElement;
        "wcs-native-select": HTMLWcsNativeSelectElement;
        "wcs-nav": HTMLWcsNavElement;
        "wcs-nav-item": HTMLWcsNavItemElement;
        "wcs-progress-bar": HTMLWcsProgressBarElement;
        "wcs-progress-radial": HTMLWcsProgressRadialElement;
        "wcs-radio": HTMLWcsRadioElement;
        "wcs-radio-group": HTMLWcsRadioGroupElement;
        "wcs-select": HTMLWcsSelectElement;
        "wcs-select-option": HTMLWcsSelectOptionElement;
        "wcs-skeleton-circle": HTMLWcsSkeletonCircleElement;
        "wcs-skeleton-rectangle": HTMLWcsSkeletonRectangleElement;
        "wcs-skeleton-text": HTMLWcsSkeletonTextElement;
        "wcs-spinner": HTMLWcsSpinnerElement;
        "wcs-switch": HTMLWcsSwitchElement;
        "wcs-tab": HTMLWcsTabElement;
        "wcs-tabs": HTMLWcsTabsElement;
        "wcs-textarea": HTMLWcsTextareaElement;
        "wcs-tooltip": HTMLWcsTooltipElement;
    }
}
declare namespace LocalJSX {
    /**
     * The accordion component is a vertical stack of interactive headings used to toggle the display of further information.
     */
    interface WcsAccordion {
        /**
          * Specifies wether accordion-panel components should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether accordion-panel components should display the open/close text. if false, it won't show the open/close text in all accordion-panel.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether accordion-panel components should highlight when open with primary color. if true, the background color of the accordion-panel will be the primary color. if false, the background color of the accordion-panel will be wcs-light.
         */
        "highlight"?: boolean;
    }
    /**
     * The accordion-content is a subcomponent of `wcs-accordion`. It represents the text / content below an expanded accordion.
     */
    interface WcsAccordionContent {
    }
    /**
     * The accordion-header is a subcomponent of `wcs-accordion`. It represents the heading text inside the accordion panel.
     */
    interface WcsAccordionHeader {
    }
    /**
     * The accordion-panel is a subcomponent of `wcs-accordion`. It represents every panel of the accordion that can be expanded.
     */
    interface WcsAccordionPanel {
        /**
          * Specifies wether the component should group the content with header in one card if true, there will be only one card with the header and the content Nothing change when the panel is close
         */
        "groupContentWithHeader"?: boolean;
        /**
          * Specifies whether the component should display the open/close text. if false, it won't show the open/close text.
         */
        "hideActionText"?: boolean;
        /**
          * Specifies whether the component should highlight when open with primary color. if true, the background color will be the primary color. if false, the background color will be wcs-light.
         */
        "highlight"?: boolean;
        "onWcsOpenChange"?: (event: WcsAccordionPanelCustomEvent<boolean>) => void;
        "open"?: boolean;
    }
    /**
     * The action-bar component is a group of elements appearing across the top of all pages on a business application.
     */
    interface WcsActionBar {
        /**
          * Determines if the action bar should have a border at the bottom. You should not use this property if a gutter is already present on tabs
         */
        "gutter"?: boolean;
    }
    interface WcsApp {
    }
    /**
     * The badge component is a small label, generally appearing inside or in proximity to another larger interface component,
     * representing a status, property, or some other metadata.
     * @cssprop --wcs-badge-ligther-percentage - Define the opacity rate to apply to the badge
     */
    interface WcsBadge {
        /**
          * Allows you to change the color of the badge to make it less bright (based on the color chosen by the CSS class).
         */
        "color"?: BadgeColor;
        /**
          * Define the shape of the badge
         */
        "shape"?: BadgeShape;
        /**
          * Specify the size of the badge.
         */
        "size"?: BadgeSize;
    }
    /**
     * A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order.  
     * It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.  
     * ## Accessibility guidelines 💡
     * > If the last item is a link to the current page, you must set the `aria-current` attribute to `page`.  
     * > If the element representing the current page is not a link, aria-current is optional.
     */
    interface WcsBreadcrumb {
    }
    interface WcsBreadcrumbItem {
    }
    /**
     * The button component is used to trigger an action. It can also be a link when specifying href.
     * ## Accessibility guidelines 💡
     * > If your button doesn't contain text but only an image, you must set a relevant aria-label on the icon 👉 [see "Square" story below](#square)
     * ## Click event
     * The WCS button relies on the native click event to pass a user click to your app.
     * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
     * This means you'll receive click events on a disabled wcs button.
     * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
     * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
     */
    interface WcsButton {
        /**
          * Specify whether the button is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Set a URL to point to.<br/> If specified use a `a` tag instead of `btn`.
         */
        "href"?: string;
        /**
          * Flag to display spinner until the end of action
         */
        "loading"?: boolean;
        /**
          * This attribute specify the appearance of the button.
         */
        "mode"?: WcsButtonMode;
        /**
          * Specify whether the button should have a ripple effect or not.
         */
        "ripple"?: boolean;
        /**
          * Specify the shape of the button.
         */
        "shape"?: WcsButtonShape;
        /**
          * Specify the size of the button.
         */
        "size"?: WcsButtonSize;
        /**
          * Specifies where to open the linked document when using href (see prop above)<br/> Default '_self' will open the linked document in the same frame as it was clicked
         */
        "target"?: '_blank' | '_self';
        /**
          * Specify the button type.
         */
        "type"?: WcsButtonType;
    }
    /**
     * The card component is a container that display content such as text, images, buttons, and lists.  
     * A card can be a single component, but is often made up of a header, title, subtitle, and content.
     */
    interface WcsCard {
        "mode"?: CardMode;
    }
    /**
     * The card-body is a subcomponent of `wcs-card`. It represents content of the card with an extra padding around.
     */
    interface WcsCardBody {
    }
    /**
     * The checkbox component is an input for choosing one or more items from a set by checking / unchecking it.
     */
    interface WcsCheckbox {
        /**
          * If `true`, the checkbox is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the checkbox is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * If `true` the checkbox is in indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Specifie the alignment of the checkbox with the label content
         */
        "labelAlignment"?: CheckboxLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the checkbox loses focus.
         */
        "onWcsBlur"?: (event: WcsCheckboxCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * Emitted when the checkbox has focus.
         */
        "onWcsFocus"?: (event: WcsCheckboxCustomEvent<FocusEvent>) => void;
    }
    /**
     * *Part of communication design system*
     * The com-nav component is a container for navigation links to external or internal pages of the website.
     */
    interface WcsComNav {
        /**
          * Name of the application to be displayed in the menu bar
         */
        "appName"?: string;
    }
    /**
     * The com-nav-category is a subcomponent of `wcs-com-nav`. It represents a category nested inside a `wcs-com-nav-submenu`.
     */
    interface WcsComNavCategory {
        "label"?: string;
        "onWcsCategoryItemClicked"?: (event: WcsComNavCategoryCustomEvent<UIEvent>) => void;
        "onWcsCategoryOpened"?: (event: WcsComNavCategoryCustomEvent<CategoryOpenedEventDetail>) => void;
    }
    /**
     * The com-nav-item is a subcomponent of `wcs-com-nav`. It represents a list-item wrapper around a link.
     */
    interface WcsComNavItem {
    }
    /**
     * The com-nav-submenu is a subcomponent of `wcs-com-nav`. It represents an expandable menu containing more items or categories.
     */
    interface WcsComNavSubmenu {
        "label"?: string;
        /**
          * Emitted when a user click on a final navigation action.  Used by the com-nav component to close the mobile menu overlay when a user click on a final action.
         */
        "onWcsClickOnFinalAction"?: (event: WcsComNavSubmenuCustomEvent<void>) => void;
        "onWcsSubmenuOpened"?: (event: WcsComNavSubmenuCustomEvent<MenuOpenedEventDetail>) => void;
        "panelDescription"?: string;
        "panelTitle"?: string;
    }
    /**
     * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
     * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
     */
    interface WcsCounter {
        /**
          * Specify whether the counter is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * The label of the counter.<br/> e.g. Number of passengers, train carriages, railroad tracks...
         */
        "label": string;
        /**
          * The maximum value of the counter. If the value of the max attribute isn't set, then the element has no maximum value.
         */
        "max"?: number;
        /**
          * The minimum value of the counter. If the value of the min attribute isn't set, then the element has no minimum value.
         */
        "min"?: number;
        /**
          * Emitted when the counter loses focus.
         */
        "onWcsBlur"?: (event: WcsCounterCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value of the counter has changed.
         */
        "onWcsChange"?: (event: WcsCounterCustomEvent<CounterChangeEventDetail>) => void;
        /**
          * Specify the size (height) of the counter.
         */
        "size"?: WcsCounterSize;
        /**
          * Defines by how much the counter will be incremented or decremented.
         */
        "step"?: number;
        /**
          * The current value of the counter.
         */
        "value": number;
    }
    interface WcsDivider {
    }
    /**
     * The dropdown component use a wcs-button under the hood, so you can use the same css classes as the button to style the
     * dropdown.
     */
    interface WcsDropdown {
        /**
          * Specifies whether the dropdown button is clickable or not
         */
        "disabled"?: boolean;
        /**
          * Dropdown's button mode
         */
        "mode"?: WcsButtonMode;
        /**
          * Hides the arrow in the button
         */
        "noArrow"?: boolean;
        /**
          * placement of the dropdown's popover
         */
        "placement"?: WcsDropdownPlacement;
        /**
          * Dropdown's button shape
         */
        "shape"?: WcsButtonShape;
        /**
          * Dropdown's button size
         */
        "size"?: WcsButtonSize;
    }
    /**
     * You can add a divider between groups of items
     */
    interface WcsDropdownDivider {
    }
    /**
     * You can add `wcs-dropdown-header` before a group of items to describe it
     */
    interface WcsDropdownHeader {
    }
    /**
     * You must add `wcs-dropdown-item` to `wcs-dropdown`
     */
    interface WcsDropdownItem {
        /**
          * Event emitted when the dropdown item is clicked
         */
        "onWcsDropdownItemClick"?: (event: WcsDropdownItemCustomEvent<void>) => void;
    }
    /**
     * The editable-field component can be used to simplify the user experience, avoiding the use of a redirection to a form
     * to edit the data of an entity. You can use it with these wrapped components : `wcs-input`, `wcs-textarea`, `wcs-select`. 
     * This component is not present in the SNCF design system specifications, so we tried to build it in the most
     * "discoverable" way possible (for users who interact with), but it's a first version.
     * **How to use ❓**  
     * This component is mostly used with a server that returns a response to the input sent through the `wcsChange` event.
     * It has 3 internal states :
     * - DISPLAY = the default state of the editable-field
     * - EDIT = the editable-field is editable, the user should input the data
     * - LOADING = the data is submitted and the editable-field is waiting for a **response**
     * A **response** is needed to get the component out of the LOADING state. You can either :
     * - Set the `value` property to a different value to tell the component to refresh and go back into DISPLAY state
     * - Use the `successHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * - Use the `errorHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
     * **Accessibility guidelines 💡**  
     * > - Aria attributes are put on the native component on the first rendering with the `label` and `errorMsg` you provided 
     * > - Additional aria attributes put on `<wcs-editable-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface WcsEditableField {
        /**
          * Error message displayed under the field if validation failed.
         */
        "errorMsg"?: string;
        /**
          * Function used to format the value
         */
        "formatFn"?: FormatFn<any>;
        /**
          * Label of the field
         */
        "label": string;
        /**
          * Event called at each (valid) update of the field.
         */
        "onWcsChange"?: (event: WcsEditableFieldCustomEvent<EditableComponentUpdateEvent>) => void;
        /**
          * Specify whether the field is editable or not
         */
        "readonly"?: boolean;
        /**
          * Specify the size (height) of the editable field.
         */
        "size"?: WcsEditableFieldSize;
        /**
          * Specifies which component is used for editing
         */
        "type"?: EditableFieldType;
        /**
          * Function to customize the validation of the data during the update
         */
        "validateFn"?: ValidateFn<any>;
        /**
          * Initial value of the field
         */
        "value"?: any;
    }
    /**
     * The `wcs-error` should always be wrapped in a `wcs-form-field`.
     * It is used to display a red message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant error message to inform the users what they should change to make the field valid
     * - `aria-description` will be automatically added to the field for screen readers
     * - `aria-invalid="true"` will be automatically added to the field for screen readers
     */
    interface WcsError {
    }
    /**
     * This field component can be used to display the details of an entity. It is built around the label and the content of the field.
     */
    interface WcsField {
    }
    /**
     * The field-content is a subcomponent of `wcs-field`. It represents the text content of the field.
     */
    interface WcsFieldContent {
    }
    /**
     * The field-label is a subcomponent of `wcs-field`. It represents the label or title of the field.
     */
    interface WcsFieldLabel {
    }
    /**
     * The footer component has been designed to leave as much customization as possible to the developer. The footers are often specific to the application developed.
     */
    interface WcsFooter {
    }
    /**
     * Form field component wraps the native input element and add some more functionality on top of it.
     * You can use the `wcs-form-field` to wrap any of these components :
     * - `wcs-input`
     * - `wcs-textarea`
     * - `wcs-radio-group`
     * - `wcs-switch`
     * - `wcs-checkbox`
     * - `wcs-native-select`
     * - `wcs-select`
     * - `wcs-counter`
     * For non-supported slotted component, you can use the `required` attribute on the wrapped component to tell the
     * form-field that it is required. It will add a red star after the label of the form field.
     * ## Accessibility guidelines 💡
     * - Each form control should be identified with a unique `wcs-label`
     * - Don't forget to add form validation to make sure the data is correctly formatted
     * - If the `wcs-label` is required, the form control must have the `required` HTML attribute and vice-versa (this is normally automatically set)
     * - The form should not be submittable if at least one required form control is not filled
     * - Hints are optional and should only be used to add extra information
     * - Additional aria attributes put on `<wcs-form-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
     */
    interface WcsFormField {
        /**
          * Specifies whether the form field is in an error state. Displays the field border in red and the message contained in the wcs-error component
         */
        "isError"?: boolean;
    }
    interface WcsGalactic {
        /**
          * Text to display in the bar
         */
        "text"?: string;
    }
    interface WcsGalacticMenu {
        /**
          * Text to be displayed in the galactic bar
         */
        "text"?: string;
    }
    /**
     * The grid component is a complex component used as an HTML table to display collections of data.
     * @cssprop --wcs-grid-highlight-color - Color for selected rows
     * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
     */
    interface WcsGrid {
        /**
          * Contains the data to display in the table from a js object
         */
        "data"?: any[];
        /**
          * Flag to display a spinner during data loading
         */
        "loading"?: boolean;
        /**
          * Event emitted when the grid loses focus.
         */
        "onWcsBlur"?: (event: WcsGridCustomEvent<FocusEvent>) => void;
        /**
          * Event emitted when the grid has focus.
         */
        "onWcsFocus"?: (event: WcsGridCustomEvent<FocusEvent>) => void;
        /**
          * Event emitted when all rows are selected or unselected
         */
        "onWcsGridAllSelectionChange"?: (event: WcsGridCustomEvent<WcsGridAllRowSelectedEventDetails>) => void;
        /**
          * Event emitted when a row is selected or unselected
         */
        "onWcsGridSelectionChange"?: (event: WcsGridCustomEvent<WcsGridSelectionEventDetails>) => void;
        /**
          * Function to add css parts to the grid rows, this allows you to customize the rows with css parts directly in you're application stylesheet.
         */
        "rowCssPartsFn"?: RowCssPartsFn;
        /**
          * Name of the object's key that will be used to display the cells whose `keyValue` attribute matches to the object's value for this key.
         */
        "rowIdPath"?: string;
        /**
          * Set the selected items (rows)
         */
        "selectedItems"?: any | any[];
        /**
          * Used to manage grid's row selection.   "none": no row can be selected.   "multiple": several rows can be selected.   "single": one row only can be selected.
         */
        "selectionConfig"?: WcsGridSelectionConfig;
        /**
          * Manage sort and pagination with a backend server when set to `true`
         */
        "serverMode"?: boolean;
        /**
          * Automatically set by the component to reference the wcs-grid-pagination HTML element by its id.
         */
        "wcsGridPaginationId"?: string;
    }
    /**
     * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
     * @cssprop --wcs-grid-column-border-left - Border separator between column names
     * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
     */
    interface WcsGridColumn {
        /**
          * This property mustn't be set by hand, it is set by the wcs-grid component to register the column index in a grid in order to move the focus between the grid columns.
         */
        "columnPosition"?: number;
        /**
          * This property mustn't be set by hand, it is set by the wcs-grid component to move the focus between grid columns using keyboard.
         */
        "cursorPosition"?: {col: number, row: number};
        /**
          * Set to true if using a `wcs-custom-cell` linked to it.
         */
        "customCells"?: boolean;
        /**
          * Customizable formatter function to render the cell differently.
         */
        "formatter"?: WcsCellFormatter;
        /**
          * Flag to hide the column.
         */
        "hidden"?: boolean;
        /**
          * The name of the column displayed on the table (e.g: First Name, Last Name, Email, ...)
         */
        "name"?: string;
        /**
          * Event emitted if the column is dynamically switching visibility.
         */
        "onWcsHiddenChange"?: (event: WcsGridColumnCustomEvent<boolean>) => void;
        /**
          * Event emitted when the sort of the column is changed.
         */
        "onWcsSortChange"?: (event: WcsGridColumnCustomEvent<WcsGridColumnSortChangeEventDetails>) => void;
        /**
          * Represents the name of the field from the `data` object (e.g: first_name, last_name, email, ...)
         */
        "path"?: string;
        /**
          * Make the column sortable.
         */
        "sort"?: boolean;
        /**
          * Customizable sort function to change the comparison of values.
         */
        "sortFn"?: WcsSortFn;
        /**
          * Defines if the column sort is ascending or descending.   `none` = the column is not sorted.
         */
        "sortOrder"?: WcsSortOrder;
        /**
          * Set the column `<th>` element width.
         */
        "width"?: string;
    }
    /**
     * The grid custom cell is a subcomponent of `wcs-grid`.
     */
    interface WcsGridCustomCell {
        /**
          * ID of the column for which to render the cell
         */
        "columnId"?: string;
        /**
          * Key value of the object rendered for the cell's row
         */
        "rowId"?: any;
    }
    /**
     * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
     */
    interface WcsGridPagination {
        /**
          * Set the available page sizes in the pagination dropdown on the left.
         */
        "availablePageSizes"?: number[];
        /**
          * The current page of the pagination. First page starts at index 0.
         */
        "currentPage"?: number;
        /**
          * Total elements in the grid.   - **Grid in `Server mode`** : You have to set `itemsCount` = your total data length.   - **Grid not in Server mode** : Do not set it manually : itemsCount is set and updated every pagination refresh.
         */
        "itemsCount"?: number;
        /**
          * Event emitted when the pagination changes.
         */
        "onWcsGridPaginationChange"?: (event: WcsGridPaginationCustomEvent<WcsGridPaginationChangeEventDetails>) => void;
        /**
          * Max number of pages.   - **Grid in `Server mode`** : You have to set `pageCount` = `itemsCount` divided by `pageSize`.   - **Grid not in Server mode** : Do not set it manually : pageCount is set and updated every pagination refresh.
         */
        "pageCount"?: number;
        /**
          * Maximum number of elements shown per page.   Default is the first value of `availablePageSizes`.
         */
        "pageSize"?: number;
    }
    /**
     * The header component is an element that appears across the top of all pages on a website or application; it contains the logo, the site name and main actions.
     */
    interface WcsHeader {
    }
    /**
     * The `wcs-hint` should always be wrapped in a `wcs-form-field`.
     * It is used to display an informative message under the field indicating an incorrect user input.
     * ## Accessibility guidelines 💡
     * - Provide a relevant hint message to inform the users about the format, how the data should be filled in, or what is the purpose of the field
     * - `aria-description` will be automatically added to the field for screen readers
     */
    interface WcsHint {
        /**
          * Whether the component should display the small version of the hint
         */
        "small"?: boolean;
    }
    /**
     * The horizontal-stepper is a representation of a user’s progress through a series of discrete steps.
     */
    interface WcsHorizontalStepper {
        /**
          * Specifies whether a check should be displayed when a step is passed.
         */
        "checkOnComplete"?: boolean;
        /**
          * index of the active step. The index corresponds to the index of the step in the 'steps' list
         */
        "currentStep"?: number;
        /**
          * Specifies if the stepper is in linear mode (the user can only click on the next step) or non-linear (the user can click on any step)
         */
        "mode"?: HorizontalStepperMode;
        /**
          * Emits when the user selects a new step.
         */
        "onWcsHorizontalStepClick"?: (event: WcsHorizontalStepperCustomEvent<HorizontalStepClickEvent>) => void;
        /**
          * steps to display
         */
        "steps"?: HorizontalStepConfig[];
    }
    /**
     * The icon component is a graphic symbol designed to visually indicate the purpose of an interface element.
     */
    interface WcsIcon {
        "icon"?: string;
        "size"?: 'x5' | 'x75' | '1x' | '1x2' | '1x5' | '1x7' | '2x' | '3x' | '30px' | '50px' | '66px' | '90px' | '96px' | '140px';
    }
    /**
     * The input component is a form control that accepts a single line of text.
     * Implementation mainly inspired from Ionic Input Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-input outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     */
    interface WcsInput {
        /**
          * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
         */
        "accept"?: string;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        "autocapitalize"?: string;
        /**
          * Indicates whether the value of the control can be automatically completed by the browser.
         */
        "autocomplete"?: AutocompleteTypes;
        /**
          * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        "autocorrect"?: WcsInputAutocorrect;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsInput` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the input.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display.
         */
        "enterkeyhint"?: WcsInputEnterKeyHint;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display.
         */
        "inputmode"?: WcsInputInputMode;
        /**
          * The maximum value, which must not be less than its minimum (min attribute) value.
         */
        "max"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * The minimum value, which must not be greater than its maximum (max attribute) value.
         */
        "min"?: string;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * If `true`, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed. See https://developer.mozilla.org/en-US/docs/Web/Events/change
         */
        "onWcsChange"?: (event: WcsInputCustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred. See https://developer.mozilla.org/en-US/docs/Web/Events/input
         */
        "onWcsInput"?: (event: WcsInputCustomEvent<KeyboardEvent>) => void;
        /**
          * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, `"date"`, or `"password"`, otherwise it is ignored. When the type attribute is `"date"`, `pattern` will only be used in browsers that do not support the `"date"` input type natively. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date for more information.
         */
        "pattern"?: string;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * Prefix displayed before the text field contents. This is not included in the value.
         */
        "prefixLabel"?: string;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * Specify the size (height) of the input.
         */
        "size"?: WcsInputSize;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an normal state but you can to set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: WcsInputState;
        /**
          * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
         */
        "step"?: string;
        /**
          * Suffix displayed after the text field contents. This is not included in the value.
         */
        "suffixLabel"?: string;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: TextFieldTypes;
        /**
          * The value of the input.
         */
        "value"?: string | number | null;
    }
    /**
     * The `wcs-label` should always be wrapped in a `wcs-form-field`.
     * It is used to caption a form control component.
     * ## Accessibility guidelines 💡
     * - Use concise name for the label. If you want to describe more your form control, add a `wcs-hint`
     * - Use the required flag only as an indication to inform users that the form control is required
     */
    interface WcsLabel {
        /**
          * If `true`, marks the label with a red star. Automatically added if the wrapped component inside the `wcs-form-field` already has the `required` attribute.
         */
        "required"?: boolean;
    }
    /**
     * Lists are used for grouping a collection of related items.
     * Standard lists can be used either with or without icons. Depending on the context, the list can have one or more
     * actions (favourite, download, delete, etc.). Use standard lists with a unique action when each line has an action.
     */
    interface WcsListItem {
        /**
          * True if the item is active. Adds a background color that highlights it.
         */
        "activated"?: boolean;
    }
    /**
     * The list-item-properties is a subcomponent of `wcs-list-item`. It represents a wrapper for a list of several `wcs-property`.
     */
    interface WcsListItemProperties {
    }
    /**
     * The list-item-property is a subcomponent of `wcs-list-item`.
     * Wrapped in a `wcs-list-item-properties`, it represents a property to describe an item.
     */
    interface WcsListItemProperty {
    }
    /**
     * A component used to display a [Material Icon](https://fonts.google.com/icons). Can be useful when used in wcs-grid or in a wcs-button.
     */
    interface WcsMatIcon {
        /**
          * Family of the icon
         */
        "family"?: MaterialIconFamily;
        /**
          * Use the icon name from Material Icons
         */
        "icon"?: string;
        /**
          * Size of the icon
         */
        "size"?: MaterialIconSize;
    }
    /**
     * The modal component (also named dialog or popup) is an interface element that appears on top of the page content.
     * Use it to show a message, a confirmation dialog, or any other content like forms.
     * ## Accessibility guidelines 💡
     * > - Modal element has `role="dialog"` and `aria-modal="true"`
     * > - Keyboard navigation is trapped inside the modal
     * > - It is mandatory to set the `modal-trigger-controls-id` to the id of the element that opens the dialog, in order
     * > to focus it upon dialog dismissal.
     * > - The modal can be closed at any time by pressing the Escape key.
     * >
     * > - More info : https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/
     * @cssprop --wcs-modal-max-height - Max height of the main container
     * @cssprop --wcs-modal-overflow-y - Overflow-y of the content
     */
    interface WcsModal {
        /**
          * Specifies the aria-label present on the close button when the modal is opened.   Only use when `showCloseButton` is `true`.
         */
        "closeButtonAriaLabel"?: string;
        /**
          * Specifies whether the component should hide the actions slot or not
         */
        "hideActions"?: boolean;
        /**
          * Specifies which element id controls the modal
          * @private
         */
        "modalTriggerControlsId"?: string;
        /**
          * Triggered when the user leaves the dialog with the closing button.
         */
        "onWcsDialogClosed"?: (event: WcsModalCustomEvent<void>) => void;
        /**
          * Displays the modal
         */
        "show"?: boolean;
        /**
          * Specifies whether the component should display a close button. if false, it won't close the modal when the escape key is pressed.
         */
        "showCloseButton"?: boolean;
        /**
          * There are multiple sizes for modals. The default size is medium (m), however other sizes are available. Select the size best suited for the content and screen size displaying the modal. Remember to test responsiveness.
         */
        "size"?: ModalSize;
        /**
          * Specifies whether the component should display a backdrop on the entire page
         */
        "withoutBackdrop"?: boolean;
    }
    /**
     * The `wcs-native-select` component is designed to accept a native `<select>` element as a slotted child. This choice
     * allows developers to bind the `<select>` element using the framework of their choice, without the need to re-expose all the
     * properties of the `<select>` and `<option>` elements in this component.
     * The component wraps the native `<select>` element and provides custom styles and behavior, while preserving the native
     * functionality and accessibility.
     * ### ✅ Guidance
     * - To have a placeholder, you must have an option as child which has `selected` attribute and `disabled`
     * attribute. You can add the `hidden` attribute to don't show the placeholder option in the options overlay.
     * ### Example usage
     * ```html
     * <wcs-native-select>
     *   <select>
     *     <option value="option1">Option 1</option>
     *     <option value="option2">Option 2</option>
     *     <option value="option3">Option 3</option>
     *   </select>
     * </wcs-native-select>
     * ```
     * ### Note
     * - We did not find a way to detect when the select is reset, if you want to apply the placeholder style when the
     * select is reset, you have to call the `updateStyles()` method manually.
     * - It is strongly recommended to use native-select when you don't have to support the multi-selection feature
     * - Use a native-select instead of a wcs-select if your application is mainly on mobile / tablet. The native behavior of the device will be used.
     */
    interface WcsNativeSelect {
        /**
          * The `size` property controls the size of the slotted `select` element by adjusting its padding. There are two possible size options: - 'm': medium size - 'l': large size  The default value is 'm'.
         */
        "size"?: WcsNativeSelectSize;
    }
    /**
     * The nav component is a container for navigation links to other pages of the website.
     */
    interface WcsNav {
    }
    /**
     * The nav-item component is a subcomponent of `wcs-nav` and should always be used inside it.  
     * They contain links to navigate to other pages of the website.
     */
    interface WcsNavItem {
    }
    /**
     * The progress-bar component is a horizontal bar that indicates the current completion of a task.
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-bar depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-bar is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-bar in a card, stepper, ...)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-bar is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-bar.
     * >   - **Set the `showLabel` property to `true`** to show the percentage above the progress-bar.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     * @cssprop --wcs-progress-bar-border-radius - Border radius
     * @cssprop --wcs-progress-bar-border-radius-small - Border radius for size small
     * @cssprop --wcs-progress-bar-animation-duration - Animation duration
     */
    interface WcsProgressBar {
        /**
          * Whether it displays a label indicating the percentage of progress above the bar.
         */
        "showLabel"?: boolean;
        /**
          * Specify the size of the progress bar. m = default, s = smaller
         */
        "size"?: Extract<WcsSize, 'm' | 's'>;
        /**
          * The actual value of the progress. Ranging from 0 to 100.
         */
        "value"?: number;
    }
    /**
     * The progress-radial component is a circular progress bar that indicates the current completion of a task. 
     * ## Accessibility guidelines 💡
     * > Aria attributes and how to display the progress-radial depend on the use case in your application :
     * >
     * > - **Case 1 : decorative**
     * > If the progress-radial is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
     * > context of another component _(such as progress-radial in a card)_ => **you don't need to show the label nor add an aria-label**.
     * >
     * > - **Case 2 : informative**
     * > If the progress-radial is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
     * >   - **Provide a visible label** that describes the purpose of the progress-radial.
     * >   - **Set the `showLabel` property to `true`** to show the percentage inside the progress-radial.
     * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
     */
    interface WcsProgressRadial {
        /**
          * Whether the component should display the % label inside
         */
        "showLabel"?: boolean;
        /**
          * The size of the progress radial (in px)
         */
        "size"?: number;
        /**
          * The value of the progress radial. Prefer values between 0 and 100.
         */
        "value"?: number;
    }
    /**
     * The radio component should always be wrapped in a `wcs-radio-group`.
     */
    interface WcsRadio {
        /**
          * If `true`, the user cannot interact with the radio.
         */
        "disabled"?: boolean;
        /**
          * The label text displayed for the user
         */
        "label"?: string;
        /**
          * The display mode of the control, automatically set by the radio group.   (You shouldn't set this prop by yourself)
         */
        "mode"?: RadioGroupMode;
        /**
          * The name of the control, automatically set by the radio group.   (You shouldn't set this prop by yourself)
         */
        "name"?: string;
        /**
          * Emitted when the radio loses focus.
         */
        "onWcsBlur"?: (event: WcsRadioCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the radio has focus.
         */
        "onWcsFocus"?: (event: WcsRadioCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the radio is clicked or Space/Enter is pressed above an unchecked radio
         */
        "onWcsRadioClick"?: (event: WcsRadioCustomEvent<RadioChosedEvent>) => void;
        /**
          * Sets a unique value for each radio, used to identify which radio button in a group is selected
         */
        "value"?: any | any[] | undefined | null;
    }
    interface WcsRadioGroup {
        /**
          * The display mode of the control to be set on all radio button children
         */
        "mode"?: RadioGroupMode;
        /**
          * The name of the control to be set on all radio button children
         */
        "name"?: any;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        /**
          * The value of the radio-group. Automatically reflects which radio button is selected.
         */
        "value"?: any | any[] | undefined | null;
    }
    /**
     * The select component (also named combobox) is a form component that allows users to select one or more options
     * from a list.
     * Use it with several slotted `wcs-select-option` inside.
     */
    interface WcsSelect {
        /**
          * If `true`, the select acts as an autocomplete field to filter your results.
         */
        "autocomplete"?: boolean;
        /**
          * If `true`, selected items are shown in chips mode.
         */
        "chips"?: boolean;
        /**
          * Function used to compare options, default : deep comparison.
         */
        "compareWith"?: (optionValue: any, selectedValue: any) => boolean;
        /**
          * If `true`, the user cannot interact with the select.
         */
        "disabled"?: boolean;
        /**
          * Customizable sort function to change the comparison of values. If not provided, uses the default behavior : `option.textContent.toLowerCase().startsWith(filter.toLowerCase())`
         */
        "filterFn"?: WcsSelectFilterFn;
        /**
          * If `true`, the user can select multiple values at once.
         */
        "multiple"?: boolean;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the select loses focus.
         */
        "onWcsBlur"?: (event: WcsSelectCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onWcsChange"?: (event: WcsSelectCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the autocomplete filter has changed.
         */
        "onWcsFilterChange"?: (event: WcsSelectCustomEvent<SelectFilterChangeEventDetail>) => void;
        /**
          * Emitted when the select has focus.
         */
        "onWcsFocus"?: (event: WcsSelectCustomEvent<FocusEvent>) => void;
        /**
          * The text to display when the select is empty.
         */
        "placeholder"?: string | null;
        /**
          * Specify the size (height) of the select.
         */
        "size"?: WcsSelectSize;
        /**
          * The currently selected value.
         */
        "value"?: any | null;
    }
    /**
     * The select option is a subcomponent of `wcs-select` that represents a single option in a select list.
     */
    interface WcsSelectOption {
        /**
          * Chip's background color.
         */
        "chipBackgroundColor"?: string;
        /**
          * Chip's displayed text color.
         */
        "chipColor"?: string;
        /**
          * Whether this option can be selected.
         */
        "disabled"?: boolean;
        /**
          * This property mustn't be set by hand, it is used by the `wcs-select` component. Applies a highlight design on the option for autocomplete mode.
          * @ignore
         */
        "highlighted"?: boolean;
        /**
          * This property mustn't be set by hand, it is used by the `wcs-select` component. If you want a multiple select, set `multiple` attribute on the parent select instead.
          * @ignore
         */
        "multiple"?: boolean;
        "onWcsSelectOptionClick"?: (event: WcsSelectOptionCustomEvent<SelectOptionChosedEvent>) => void;
        /**
          * Whether this option is selected.
         */
        "selected"?: boolean;
        /**
          * The option value, not what's displayed, use inner text instead.
         */
        "value"?: any;
    }
    /**
     * Use a skeleton circle as a placeholder round images, illustrations or components
     */
    interface WcsSkeletonCircle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the radius of the circle in px
         */
        "radius"?: number;
    }
    /**
     * Use a skeleton rectangle as a placeholder for large images or square-shaped components
     * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
     */
    interface WcsSkeletonRectangle {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the height of the skeleton (can be any valid CSS value)
         */
        "height"?: CssTypes.Height;
        /**
          * Adds a border radius on the skeleton if true
         */
        "rounded"?: boolean;
        /**
          * Specifies the width of the skeleton (can be any valid CSS value)
         */
        "width"?: CssTypes.Width;
    }
    /**
     * Use a skeleton text as a placeholder for titles or paragraphs.
     */
    interface WcsSkeletonText {
        /**
          * Specifies the animation of the skeleton
         */
        "animation"?: WcsSkeletonAnimation;
        /**
          * Specifies the line height of the text skeleton
         */
        "height"?: 'h1' | 'h2' | 'h3' | 'caption' | 'body';
    }
    /**
     * The spinner component is visual indicator that showing a process is happening in the background but the interface is
     * not yet ready for interaction.  
     * If your page structure is simple or the loading time is long (> 300ms), use [wcs-skeleton](.?path=/docs/components-skeleton--documentation) instead.
     */
    interface WcsSpinner {
        /**
          * Indicates the spinner display mode. Accepted values: `border` or `growing`
         */
        "mode"?: WcsSpinnerMode;
    }
    /**
     * The switch component is a control used to switch between on and off state.
     */
    interface WcsSwitch {
        /**
          * If `true`, the switch is selected.
         */
        "checked"?: boolean;
        /**
          * Specify wether the switch is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Specifie the alignment of the switch with the label content
         */
        "labelAlignment"?: SwitchLabelAlignment;
        "name"?: string;
        /**
          * Emitted when the switch loses focus.
         */
        "onWcsBlur"?: (event: WcsSwitchCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the checked property has changed.
         */
        "onWcsChange"?: (event: WcsSwitchCustomEvent<SwitchChangeEventDetail>) => void;
        /**
          * Emitted when the switch has focus.
         */
        "onWcsFocus"?: (event: WcsSwitchCustomEvent<FocusEvent>) => void;
    }
    /**
     * Tab content component.
     * Use this component to specify the content of a component.
     */
    interface WcsTab {
        /**
          * The header you want to be displayed for this tab.
         */
        "header"?: string;
        /**
          * The id of the tab. It should be unique.
         */
        "itemKey"?: any;
        /**
          * Do not use, meant for internal use only.
          * @inner 
          * @ignore
         */
        "onTabLoaded"?: (event: WcsTabCustomEvent<void>) => void;
    }
    /**
     * Tabs component to switch between tab content.
     * Use in conjuction with `wcs-tab`.
     * @example ```html
     * <wcs-tabs>
     *    <wcs-tab header="One">The content !</wcs-tab>
     *    <wcs-tab header="Two">More content !</wcs-tab>
     * </wcs-tabs>
     * ```
     * @cssprop --wcs-tabs-width - Width of each tab
     * @cssprop --wcs-tabs-padding-horizontal - Width of each tab
     * @cssprop --wcs-tabs-padding-vertical - Vertical padding
     */
    interface WcsTabs {
        /**
          * Tab headers alignment.
         */
        "align"?: WcsTabsAlignment;
        /**
          * Description is used to provide aria-label for the tabs container which has `role="tablist"`.
         */
        "description"?: string;
        /**
          * Determines if tabs header should have a border at the bottom
         */
        "gutter"?: boolean;
        /**
          * Whether to skip rendering the tabpanel with the content of the selected tab. Use this prop if you plan to separately render the tab content.
         */
        "headersOnly"?: boolean;
        /**
          * Emitted when the selected tab change.
         */
        "onTabChange"?: (event: WcsTabsCustomEvent<WcsTabChangeEvent>) => void;
        /**
          * Current selected tab index. Starts at 0.
         */
        "selectedIndex"?: number;
        "selectedKey"?: any;
    }
    /**
     * Mainly inspired from Ionic Textarea Component.
     * ## Accessibility guidelines 💡
     * > - If you use wcs-textarea outside a wcs-form-field, you have to manage the label and the error message yourself.
     * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
     * @cssprop --wcs-textarea-max-height - Max height of the text area component
     * @cssprop --wcs-textarea-padding-left - Padding left of the text area. Take in consideration the transparent border of 2px around the textarea.
     * @cssprop --wcs-textarea-padding-right - Padding right of the text area. Take in consideration the transparent border of 2px around the textarea.
     */
    interface WcsTextarea {
        /**
          * If `true`, the element height will increase based on the value.
         */
        "autoGrow"?: boolean;
        /**
          * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        "autocapitalize"?: string;
        /**
          * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.   Note : at the moment, modifying the width is only possible if you add some custom CSS to the component, for example by overriding the `width` CSS property. See the Resize section for an example on how to do it.
         */
        "cols"?: number;
        /**
          * Set the amount of time, in milliseconds, to wait to trigger the `wcsInput` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        "debounce"?: number;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * A hint to the browser for which enter key to display.
         */
        "enterkeyhint"?: WcsTextareaEnterKeyHint;
        /**
          * This is required for a WebKit bug which requires us to blur and focus an input to properly focus the input in an item with delegatesFocus. It will no longer be needed with iOS 14.
         */
        "fireFocusEvents"?: boolean;
        /**
          * Name of the material icon to add to the input
         */
        "icon"?: string;
        /**
          * A hint to the browser for which keyboard to display.
         */
        "inputmode"?: WcsTextareaInputMode;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
         */
        "maxlength"?: number;
        /**
          * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
         */
        "minlength"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onWcsBlur"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input value has changed.- See https://developer.mozilla.org/en-US/docs/Web/Events/change
         */
        "onWcsChange"?: (event: WcsTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onWcsFocus"?: (event: WcsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurred. See https://developer.mozilla.org/en-US/docs/Web/Events/input
         */
        "onWcsInput"?: (event: WcsTextareaCustomEvent<KeyboardEvent>) => void;
        /**
          * Instructional text that shows before the input has a value.
         */
        "placeholder"?: string | null;
        /**
          * If `true`, the user cannot modify the value.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the user must fill in a value before submitting a form.
         */
        "required"?: boolean;
        /**
          * Indicates how the textarea should be resizable.   Note : at the moment horizontal resizing is only possible if you add custom CSS to the component, see the Resize section for an example.
         */
        "resize"?: WcsTextareaResize;
        /**
          * The number of visible text lines for the control.
         */
        "rows"?: number;
        /**
          * If `true`, the element will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * Specifies the state of the input. By default the input is in an initial state but you can set it to 'error' state if the data given by the user is not valid.
         */
        "state"?: WcsTextareaInputState;
        /**
          * The value of the textarea.
         */
        "value"?: string | null;
        /**
          * Indicates how the control wraps text.
         */
        "wrap"?: WcsTextareaWrap;
    }
    /**
     * Tooltips are used to provide additional information for features available on the website. These can improve the user
     * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
     * (for longer content).
     * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
     * ## Accessibility guidelines 💡
     * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve
     * this problem, the tooltip should be served with some aria attributes to make it accessible.
     * Aria-features `wcs-tooltip` respect:
     * - dismiss when the user presses the `Escape` key
     * - has a `role=tooltip`
     * But you have to provide the "link" between the element you want to describe and the tooltip. To do this, you have to
     * provide the "visual description" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available 
     * of the element you want to describe .
     * Example:
     * ```html
     * <wcs-tooltip>Trashed items</wcs-tooltip>
     * <wcs-button aria-label="Trashed items">Trash</wcs-button>
     * ```
     */
    interface WcsTooltip {
        /**
          * The element to append the tooltip to. Default behaviour is `() => document.body`. If interactive: true, the default behavior is appendTo: "parent"  See: https://atomiks.github.io/tippyjs/v6/all-props/#appendto
         */
        "appendTo"?: WcsTooltipAppendTo;
        /**
          * You can use this property instead of the slot API to affect content in the tooltip.  This makes it easier to manage the update if the tooltip contains elements that are not mutated when their content changes. Indeed, if the slot is used, the tooltip is updated only if the structure of the slotted DOM changes (the DOM must be mutated).  The two APIs are not mutually exclusive, if both are filled in (the prop + the slot) the rendering will first display the content of this property and then the slotted elements.
         */
        "content"?: string;
        /**
          * Delay in ms once a trigger event is fired before the tooltip shows or hides.  You can provide an array with two values to define a different duration for show and hide.  `[showDelay, hideDelay]`  Use null to use default value.
         */
        "delay"?: number | [number, number];
        /**
          * Duration in ms of the transition animation.
         */
        "duration"?: number | [number, number];
        /**
          * The **id** of the element the tooltip's going to describe.  This property cannot be modified after initialization.
          * @example ```html <span id="tooltiped">Some content</span> <wcs-tooltip for="tooltiped">A tooltip!</wcs-tooltip> ```
         */
        "for"?: string;
        /**
          * Determines if the tooltip has interactive content inside of it, so that it can be hovered over and clicked inside without hiding.
         */
        "interactive"?: boolean;
        /**
          * Specifies the maximum width of the tooltip. Useful to prevent it from being too horizontally wide to read.  If the viewport's width is smaller than maxWidth, core CSS ensures the tippy remains smaller than the screen.  To test it on WCS documentation page, add 'px' to the control value (string type in this case).
         */
        "maxWidth"?: string | number;
        /**
          * Where the tooltip is going to show relative to the element it's describing.
         */
        "position"?: WcsTooltipPosition;
        /**
          * Allows you to change the theme used by tippy.  The WCS theme is used by default and uses the WCS CSS variables.  You can create a theme by following this documentation and choosing a custom name : https://atomiks.github.io/tippyjs/v6/themes/
         */
        "theme"?: string;
        /**
          * Determines the events that cause the tooltip to show. Multiple event names are separated by spaces.  See: https://atomiks.github.io/tippyjs/v6/all-props/#trigger
         */
        "trigger"?: string;
    }
    interface IntrinsicElements {
        "wcs-accordion": WcsAccordion;
        "wcs-accordion-content": WcsAccordionContent;
        "wcs-accordion-header": WcsAccordionHeader;
        "wcs-accordion-panel": WcsAccordionPanel;
        "wcs-action-bar": WcsActionBar;
        "wcs-app": WcsApp;
        "wcs-badge": WcsBadge;
        "wcs-breadcrumb": WcsBreadcrumb;
        "wcs-breadcrumb-item": WcsBreadcrumbItem;
        "wcs-button": WcsButton;
        "wcs-card": WcsCard;
        "wcs-card-body": WcsCardBody;
        "wcs-checkbox": WcsCheckbox;
        "wcs-com-nav": WcsComNav;
        "wcs-com-nav-category": WcsComNavCategory;
        "wcs-com-nav-item": WcsComNavItem;
        "wcs-com-nav-submenu": WcsComNavSubmenu;
        "wcs-counter": WcsCounter;
        "wcs-divider": WcsDivider;
        "wcs-dropdown": WcsDropdown;
        "wcs-dropdown-divider": WcsDropdownDivider;
        "wcs-dropdown-header": WcsDropdownHeader;
        "wcs-dropdown-item": WcsDropdownItem;
        "wcs-editable-field": WcsEditableField;
        "wcs-error": WcsError;
        "wcs-field": WcsField;
        "wcs-field-content": WcsFieldContent;
        "wcs-field-label": WcsFieldLabel;
        "wcs-footer": WcsFooter;
        "wcs-form-field": WcsFormField;
        "wcs-galactic": WcsGalactic;
        "wcs-galactic-menu": WcsGalacticMenu;
        "wcs-grid": WcsGrid;
        "wcs-grid-column": WcsGridColumn;
        "wcs-grid-custom-cell": WcsGridCustomCell;
        "wcs-grid-pagination": WcsGridPagination;
        "wcs-header": WcsHeader;
        "wcs-hint": WcsHint;
        "wcs-horizontal-stepper": WcsHorizontalStepper;
        "wcs-icon": WcsIcon;
        "wcs-input": WcsInput;
        "wcs-label": WcsLabel;
        "wcs-list-item": WcsListItem;
        "wcs-list-item-properties": WcsListItemProperties;
        "wcs-list-item-property": WcsListItemProperty;
        "wcs-mat-icon": WcsMatIcon;
        "wcs-modal": WcsModal;
        "wcs-native-select": WcsNativeSelect;
        "wcs-nav": WcsNav;
        "wcs-nav-item": WcsNavItem;
        "wcs-progress-bar": WcsProgressBar;
        "wcs-progress-radial": WcsProgressRadial;
        "wcs-radio": WcsRadio;
        "wcs-radio-group": WcsRadioGroup;
        "wcs-select": WcsSelect;
        "wcs-select-option": WcsSelectOption;
        "wcs-skeleton-circle": WcsSkeletonCircle;
        "wcs-skeleton-rectangle": WcsSkeletonRectangle;
        "wcs-skeleton-text": WcsSkeletonText;
        "wcs-spinner": WcsSpinner;
        "wcs-switch": WcsSwitch;
        "wcs-tab": WcsTab;
        "wcs-tabs": WcsTabs;
        "wcs-textarea": WcsTextarea;
        "wcs-tooltip": WcsTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * The accordion component is a vertical stack of interactive headings used to toggle the display of further information.
             */
            "wcs-accordion": LocalJSX.WcsAccordion & JSXBase.HTMLAttributes<HTMLWcsAccordionElement>;
            /**
             * The accordion-content is a subcomponent of `wcs-accordion`. It represents the text / content below an expanded accordion.
             */
            "wcs-accordion-content": LocalJSX.WcsAccordionContent & JSXBase.HTMLAttributes<HTMLWcsAccordionContentElement>;
            /**
             * The accordion-header is a subcomponent of `wcs-accordion`. It represents the heading text inside the accordion panel.
             */
            "wcs-accordion-header": LocalJSX.WcsAccordionHeader & JSXBase.HTMLAttributes<HTMLWcsAccordionHeaderElement>;
            /**
             * The accordion-panel is a subcomponent of `wcs-accordion`. It represents every panel of the accordion that can be expanded.
             */
            "wcs-accordion-panel": LocalJSX.WcsAccordionPanel & JSXBase.HTMLAttributes<HTMLWcsAccordionPanelElement>;
            /**
             * The action-bar component is a group of elements appearing across the top of all pages on a business application.
             */
            "wcs-action-bar": LocalJSX.WcsActionBar & JSXBase.HTMLAttributes<HTMLWcsActionBarElement>;
            "wcs-app": LocalJSX.WcsApp & JSXBase.HTMLAttributes<HTMLWcsAppElement>;
            /**
             * The badge component is a small label, generally appearing inside or in proximity to another larger interface component,
             * representing a status, property, or some other metadata.
             * @cssprop --wcs-badge-ligther-percentage - Define the opacity rate to apply to the badge
             */
            "wcs-badge": LocalJSX.WcsBadge & JSXBase.HTMLAttributes<HTMLWcsBadgeElement>;
            /**
             * A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order.  
             * It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.  
             * ## Accessibility guidelines 💡
             * > If the last item is a link to the current page, you must set the `aria-current` attribute to `page`.  
             * > If the element representing the current page is not a link, aria-current is optional.
             */
            "wcs-breadcrumb": LocalJSX.WcsBreadcrumb & JSXBase.HTMLAttributes<HTMLWcsBreadcrumbElement>;
            "wcs-breadcrumb-item": LocalJSX.WcsBreadcrumbItem & JSXBase.HTMLAttributes<HTMLWcsBreadcrumbItemElement>;
            /**
             * The button component is used to trigger an action. It can also be a link when specifying href.
             * ## Accessibility guidelines 💡
             * > If your button doesn't contain text but only an image, you must set a relevant aria-label on the icon 👉 [see "Square" story below](#square)
             * ## Click event
             * The WCS button relies on the native click event to pass a user click to your app.
             * For now, it's not possible for us to prevent the click event to be fired when the button's disabled attribute is true.
             * This means you'll receive click events on a disabled wcs button.
             * If you're using the button with a library like Angular or React, they have internal mechanisms to prevent this behavior. Your callbacks will therefore not be called.
             * To fix this problem, we plan to provide a wcsClick event in addition to the native click for applications developed without frameworks.
             */
            "wcs-button": LocalJSX.WcsButton & JSXBase.HTMLAttributes<HTMLWcsButtonElement>;
            /**
             * The card component is a container that display content such as text, images, buttons, and lists.  
             * A card can be a single component, but is often made up of a header, title, subtitle, and content.
             */
            "wcs-card": LocalJSX.WcsCard & JSXBase.HTMLAttributes<HTMLWcsCardElement>;
            /**
             * The card-body is a subcomponent of `wcs-card`. It represents content of the card with an extra padding around.
             */
            "wcs-card-body": LocalJSX.WcsCardBody & JSXBase.HTMLAttributes<HTMLWcsCardBodyElement>;
            /**
             * The checkbox component is an input for choosing one or more items from a set by checking / unchecking it.
             */
            "wcs-checkbox": LocalJSX.WcsCheckbox & JSXBase.HTMLAttributes<HTMLWcsCheckboxElement>;
            /**
             * *Part of communication design system*
             * The com-nav component is a container for navigation links to external or internal pages of the website.
             */
            "wcs-com-nav": LocalJSX.WcsComNav & JSXBase.HTMLAttributes<HTMLWcsComNavElement>;
            /**
             * The com-nav-category is a subcomponent of `wcs-com-nav`. It represents a category nested inside a `wcs-com-nav-submenu`.
             */
            "wcs-com-nav-category": LocalJSX.WcsComNavCategory & JSXBase.HTMLAttributes<HTMLWcsComNavCategoryElement>;
            /**
             * The com-nav-item is a subcomponent of `wcs-com-nav`. It represents a list-item wrapper around a link.
             */
            "wcs-com-nav-item": LocalJSX.WcsComNavItem & JSXBase.HTMLAttributes<HTMLWcsComNavItemElement>;
            /**
             * The com-nav-submenu is a subcomponent of `wcs-com-nav`. It represents an expandable menu containing more items or categories.
             */
            "wcs-com-nav-submenu": LocalJSX.WcsComNavSubmenu & JSXBase.HTMLAttributes<HTMLWcsComNavSubmenuElement>;
            /**
             * Counter component, meant to be used for small range of values (e.g : 0 - 5).<br>
             * For larger or specific ranges, please use [wcs-input (type number)](.?path=/docs/components-input--documentation)
             */
            "wcs-counter": LocalJSX.WcsCounter & JSXBase.HTMLAttributes<HTMLWcsCounterElement>;
            "wcs-divider": LocalJSX.WcsDivider & JSXBase.HTMLAttributes<HTMLWcsDividerElement>;
            /**
             * The dropdown component use a wcs-button under the hood, so you can use the same css classes as the button to style the
             * dropdown.
             */
            "wcs-dropdown": LocalJSX.WcsDropdown & JSXBase.HTMLAttributes<HTMLWcsDropdownElement>;
            /**
             * You can add a divider between groups of items
             */
            "wcs-dropdown-divider": LocalJSX.WcsDropdownDivider & JSXBase.HTMLAttributes<HTMLWcsDropdownDividerElement>;
            /**
             * You can add `wcs-dropdown-header` before a group of items to describe it
             */
            "wcs-dropdown-header": LocalJSX.WcsDropdownHeader & JSXBase.HTMLAttributes<HTMLWcsDropdownHeaderElement>;
            /**
             * You must add `wcs-dropdown-item` to `wcs-dropdown`
             */
            "wcs-dropdown-item": LocalJSX.WcsDropdownItem & JSXBase.HTMLAttributes<HTMLWcsDropdownItemElement>;
            /**
             * The editable-field component can be used to simplify the user experience, avoiding the use of a redirection to a form
             * to edit the data of an entity. You can use it with these wrapped components : `wcs-input`, `wcs-textarea`, `wcs-select`. 
             * This component is not present in the SNCF design system specifications, so we tried to build it in the most
             * "discoverable" way possible (for users who interact with), but it's a first version.
             * **How to use ❓**  
             * This component is mostly used with a server that returns a response to the input sent through the `wcsChange` event.
             * It has 3 internal states :
             * - DISPLAY = the default state of the editable-field
             * - EDIT = the editable-field is editable, the user should input the data
             * - LOADING = the data is submitted and the editable-field is waiting for a **response**
             * A **response** is needed to get the component out of the LOADING state. You can either :
             * - Set the `value` property to a different value to tell the component to refresh and go back into DISPLAY state
             * - Use the `successHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
             * - Use the `errorHandler` callback through the `wcsChange` event (see interface [EditableComponentUpdateEvent](https://gitlab.com/SNCF/wcs/-/blob/develop/src/components/editable-field/editable-field-interface.tsx))
             * **Accessibility guidelines 💡**  
             * > - Aria attributes are put on the native component on the first rendering with the `label` and `errorMsg` you provided 
             * > - Additional aria attributes put on `<wcs-editable-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
             */
            "wcs-editable-field": LocalJSX.WcsEditableField & JSXBase.HTMLAttributes<HTMLWcsEditableFieldElement>;
            /**
             * The `wcs-error` should always be wrapped in a `wcs-form-field`.
             * It is used to display a red message under the field indicating an incorrect user input.
             * ## Accessibility guidelines 💡
             * - Provide a relevant error message to inform the users what they should change to make the field valid
             * - `aria-description` will be automatically added to the field for screen readers
             * - `aria-invalid="true"` will be automatically added to the field for screen readers
             */
            "wcs-error": LocalJSX.WcsError & JSXBase.HTMLAttributes<HTMLWcsErrorElement>;
            /**
             * This field component can be used to display the details of an entity. It is built around the label and the content of the field.
             */
            "wcs-field": LocalJSX.WcsField & JSXBase.HTMLAttributes<HTMLWcsFieldElement>;
            /**
             * The field-content is a subcomponent of `wcs-field`. It represents the text content of the field.
             */
            "wcs-field-content": LocalJSX.WcsFieldContent & JSXBase.HTMLAttributes<HTMLWcsFieldContentElement>;
            /**
             * The field-label is a subcomponent of `wcs-field`. It represents the label or title of the field.
             */
            "wcs-field-label": LocalJSX.WcsFieldLabel & JSXBase.HTMLAttributes<HTMLWcsFieldLabelElement>;
            /**
             * The footer component has been designed to leave as much customization as possible to the developer. The footers are often specific to the application developed.
             */
            "wcs-footer": LocalJSX.WcsFooter & JSXBase.HTMLAttributes<HTMLWcsFooterElement>;
            /**
             * Form field component wraps the native input element and add some more functionality on top of it.
             * You can use the `wcs-form-field` to wrap any of these components :
             * - `wcs-input`
             * - `wcs-textarea`
             * - `wcs-radio-group`
             * - `wcs-switch`
             * - `wcs-checkbox`
             * - `wcs-native-select`
             * - `wcs-select`
             * - `wcs-counter`
             * For non-supported slotted component, you can use the `required` attribute on the wrapped component to tell the
             * form-field that it is required. It will add a red star after the label of the form field.
             * ## Accessibility guidelines 💡
             * - Each form control should be identified with a unique `wcs-label`
             * - Don't forget to add form validation to make sure the data is correctly formatted
             * - If the `wcs-label` is required, the form control must have the `required` HTML attribute and vice-versa (this is normally automatically set)
             * - The form should not be submittable if at least one required form control is not filled
             * - Hints are optional and should only be used to add extra information
             * - Additional aria attributes put on `<wcs-form-field>` won't inherit onto the native component : you must use the `setAriaAttribute` method.
             */
            "wcs-form-field": LocalJSX.WcsFormField & JSXBase.HTMLAttributes<HTMLWcsFormFieldElement>;
            "wcs-galactic": LocalJSX.WcsGalactic & JSXBase.HTMLAttributes<HTMLWcsGalacticElement>;
            "wcs-galactic-menu": LocalJSX.WcsGalacticMenu & JSXBase.HTMLAttributes<HTMLWcsGalacticMenuElement>;
            /**
             * The grid component is a complex component used as an HTML table to display collections of data.
             * @cssprop --wcs-grid-highlight-color - Color for selected rows
             * @cssprop --wcs-grid-column-border-left - Left border of all grid headers
             */
            "wcs-grid": LocalJSX.WcsGrid & JSXBase.HTMLAttributes<HTMLWcsGridElement>;
            /**
             * The grid column is a subcomponent of `wcs-grid` that represents a column of the table.
             * @cssprop --wcs-grid-column-border-left - Border separator between column names
             * @csspart [path]-column - CSS part for each column for styling. e.g: first_name-column, email-column
             */
            "wcs-grid-column": LocalJSX.WcsGridColumn & JSXBase.HTMLAttributes<HTMLWcsGridColumnElement>;
            /**
             * The grid custom cell is a subcomponent of `wcs-grid`.
             */
            "wcs-grid-custom-cell": LocalJSX.WcsGridCustomCell & JSXBase.HTMLAttributes<HTMLWcsGridCustomCellElement>;
            /**
             * The grid pagination is a subcomponent of `wcs-grid`, slotted in `grid-pagination` under the `<table>` element.
             */
            "wcs-grid-pagination": LocalJSX.WcsGridPagination & JSXBase.HTMLAttributes<HTMLWcsGridPaginationElement>;
            /**
             * The header component is an element that appears across the top of all pages on a website or application; it contains the logo, the site name and main actions.
             */
            "wcs-header": LocalJSX.WcsHeader & JSXBase.HTMLAttributes<HTMLWcsHeaderElement>;
            /**
             * The `wcs-hint` should always be wrapped in a `wcs-form-field`.
             * It is used to display an informative message under the field indicating an incorrect user input.
             * ## Accessibility guidelines 💡
             * - Provide a relevant hint message to inform the users about the format, how the data should be filled in, or what is the purpose of the field
             * - `aria-description` will be automatically added to the field for screen readers
             */
            "wcs-hint": LocalJSX.WcsHint & JSXBase.HTMLAttributes<HTMLWcsHintElement>;
            /**
             * The horizontal-stepper is a representation of a user’s progress through a series of discrete steps.
             */
            "wcs-horizontal-stepper": LocalJSX.WcsHorizontalStepper & JSXBase.HTMLAttributes<HTMLWcsHorizontalStepperElement>;
            /**
             * The icon component is a graphic symbol designed to visually indicate the purpose of an interface element.
             */
            "wcs-icon": LocalJSX.WcsIcon & JSXBase.HTMLAttributes<HTMLWcsIconElement>;
            /**
             * The input component is a form control that accepts a single line of text.
             * Implementation mainly inspired from Ionic Input Component.
             * ## Accessibility guidelines 💡
             * > - If you use wcs-input outside a wcs-form-field, you have to manage the label and the error message yourself.
             * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
             */
            "wcs-input": LocalJSX.WcsInput & JSXBase.HTMLAttributes<HTMLWcsInputElement>;
            /**
             * The `wcs-label` should always be wrapped in a `wcs-form-field`.
             * It is used to caption a form control component.
             * ## Accessibility guidelines 💡
             * - Use concise name for the label. If you want to describe more your form control, add a `wcs-hint`
             * - Use the required flag only as an indication to inform users that the form control is required
             */
            "wcs-label": LocalJSX.WcsLabel & JSXBase.HTMLAttributes<HTMLWcsLabelElement>;
            /**
             * Lists are used for grouping a collection of related items.
             * Standard lists can be used either with or without icons. Depending on the context, the list can have one or more
             * actions (favourite, download, delete, etc.). Use standard lists with a unique action when each line has an action.
             */
            "wcs-list-item": LocalJSX.WcsListItem & JSXBase.HTMLAttributes<HTMLWcsListItemElement>;
            /**
             * The list-item-properties is a subcomponent of `wcs-list-item`. It represents a wrapper for a list of several `wcs-property`.
             */
            "wcs-list-item-properties": LocalJSX.WcsListItemProperties & JSXBase.HTMLAttributes<HTMLWcsListItemPropertiesElement>;
            /**
             * The list-item-property is a subcomponent of `wcs-list-item`.
             * Wrapped in a `wcs-list-item-properties`, it represents a property to describe an item.
             */
            "wcs-list-item-property": LocalJSX.WcsListItemProperty & JSXBase.HTMLAttributes<HTMLWcsListItemPropertyElement>;
            /**
             * A component used to display a [Material Icon](https://fonts.google.com/icons). Can be useful when used in wcs-grid or in a wcs-button.
             */
            "wcs-mat-icon": LocalJSX.WcsMatIcon & JSXBase.HTMLAttributes<HTMLWcsMatIconElement>;
            /**
             * The modal component (also named dialog or popup) is an interface element that appears on top of the page content.
             * Use it to show a message, a confirmation dialog, or any other content like forms.
             * ## Accessibility guidelines 💡
             * > - Modal element has `role="dialog"` and `aria-modal="true"`
             * > - Keyboard navigation is trapped inside the modal
             * > - It is mandatory to set the `modal-trigger-controls-id` to the id of the element that opens the dialog, in order
             * > to focus it upon dialog dismissal.
             * > - The modal can be closed at any time by pressing the Escape key.
             * >
             * > - More info : https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/
             * @cssprop --wcs-modal-max-height - Max height of the main container
             * @cssprop --wcs-modal-overflow-y - Overflow-y of the content
             */
            "wcs-modal": LocalJSX.WcsModal & JSXBase.HTMLAttributes<HTMLWcsModalElement>;
            /**
             * The `wcs-native-select` component is designed to accept a native `<select>` element as a slotted child. This choice
             * allows developers to bind the `<select>` element using the framework of their choice, without the need to re-expose all the
             * properties of the `<select>` and `<option>` elements in this component.
             * The component wraps the native `<select>` element and provides custom styles and behavior, while preserving the native
             * functionality and accessibility.
             * ### ✅ Guidance
             * - To have a placeholder, you must have an option as child which has `selected` attribute and `disabled`
             * attribute. You can add the `hidden` attribute to don't show the placeholder option in the options overlay.
             * ### Example usage
             * ```html
             * <wcs-native-select>
             *   <select>
             *     <option value="option1">Option 1</option>
             *     <option value="option2">Option 2</option>
             *     <option value="option3">Option 3</option>
             *   </select>
             * </wcs-native-select>
             * ```
             * ### Note
             * - We did not find a way to detect when the select is reset, if you want to apply the placeholder style when the
             * select is reset, you have to call the `updateStyles()` method manually.
             * - It is strongly recommended to use native-select when you don't have to support the multi-selection feature
             * - Use a native-select instead of a wcs-select if your application is mainly on mobile / tablet. The native behavior of the device will be used.
             */
            "wcs-native-select": LocalJSX.WcsNativeSelect & JSXBase.HTMLAttributes<HTMLWcsNativeSelectElement>;
            /**
             * The nav component is a container for navigation links to other pages of the website.
             */
            "wcs-nav": LocalJSX.WcsNav & JSXBase.HTMLAttributes<HTMLWcsNavElement>;
            /**
             * The nav-item component is a subcomponent of `wcs-nav` and should always be used inside it.  
             * They contain links to navigate to other pages of the website.
             */
            "wcs-nav-item": LocalJSX.WcsNavItem & JSXBase.HTMLAttributes<HTMLWcsNavItemElement>;
            /**
             * The progress-bar component is a horizontal bar that indicates the current completion of a task.
             * ## Accessibility guidelines 💡
             * > Aria attributes and how to display the progress-bar depend on the use case in your application :
             * >
             * > - **Case 1 : decorative**
             * > If the progress-bar is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
             * > context of another component _(such as progress-bar in a card, stepper, ...)_ => **you don't need to show the label nor add an aria-label**.
             * >
             * > - **Case 2 : informative**
             * > If the progress-bar is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
             * >   - **Provide a visible label** that describes the purpose of the progress-bar.
             * >   - **Set the `showLabel` property to `true`** to show the percentage above the progress-bar.
             * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
             * @cssprop --wcs-progress-bar-border-radius - Border radius
             * @cssprop --wcs-progress-bar-border-radius-small - Border radius for size small
             * @cssprop --wcs-progress-bar-animation-duration - Animation duration
             */
            "wcs-progress-bar": LocalJSX.WcsProgressBar & JSXBase.HTMLAttributes<HTMLWcsProgressBarElement>;
            /**
             * The progress-radial component is a circular progress bar that indicates the current completion of a task. 
             * ## Accessibility guidelines 💡
             * > Aria attributes and how to display the progress-radial depend on the use case in your application :
             * >
             * > - **Case 1 : decorative**
             * > If the progress-radial is used as a decoration _(if removed, the user doesn't lose any relevant information)_ or in the
             * > context of another component _(such as progress-radial in a card)_ => **you don't need to show the label nor add an aria-label**.
             * >
             * > - **Case 2 : informative**
             * > If the progress-radial is used to convey important information _(e.g., form completion status, dashboard KPI)_, you need to :
             * >   - **Provide a visible label** that describes the purpose of the progress-radial.
             * >   - **Set the `showLabel` property to `true`** to show the percentage inside the progress-radial.
             * >   - Optionally, use aria-label to provide an accessible name if a visible label is not present.
             */
            "wcs-progress-radial": LocalJSX.WcsProgressRadial & JSXBase.HTMLAttributes<HTMLWcsProgressRadialElement>;
            /**
             * The radio component should always be wrapped in a `wcs-radio-group`.
             */
            "wcs-radio": LocalJSX.WcsRadio & JSXBase.HTMLAttributes<HTMLWcsRadioElement>;
            "wcs-radio-group": LocalJSX.WcsRadioGroup & JSXBase.HTMLAttributes<HTMLWcsRadioGroupElement>;
            /**
             * The select component (also named combobox) is a form component that allows users to select one or more options
             * from a list.
             * Use it with several slotted `wcs-select-option` inside.
             */
            "wcs-select": LocalJSX.WcsSelect & JSXBase.HTMLAttributes<HTMLWcsSelectElement>;
            /**
             * The select option is a subcomponent of `wcs-select` that represents a single option in a select list.
             */
            "wcs-select-option": LocalJSX.WcsSelectOption & JSXBase.HTMLAttributes<HTMLWcsSelectOptionElement>;
            /**
             * Use a skeleton circle as a placeholder round images, illustrations or components
             */
            "wcs-skeleton-circle": LocalJSX.WcsSkeletonCircle & JSXBase.HTMLAttributes<HTMLWcsSkeletonCircleElement>;
            /**
             * Use a skeleton rectangle as a placeholder for large images or square-shaped components
             * @cssprop --wcs-skeleton-border-radius - Controls the border-radius of the 'rounded' skeleton rectangle (default 0.5rem)
             */
            "wcs-skeleton-rectangle": LocalJSX.WcsSkeletonRectangle & JSXBase.HTMLAttributes<HTMLWcsSkeletonRectangleElement>;
            /**
             * Use a skeleton text as a placeholder for titles or paragraphs.
             */
            "wcs-skeleton-text": LocalJSX.WcsSkeletonText & JSXBase.HTMLAttributes<HTMLWcsSkeletonTextElement>;
            /**
             * The spinner component is visual indicator that showing a process is happening in the background but the interface is
             * not yet ready for interaction.  
             * If your page structure is simple or the loading time is long (> 300ms), use [wcs-skeleton](.?path=/docs/components-skeleton--documentation) instead.
             */
            "wcs-spinner": LocalJSX.WcsSpinner & JSXBase.HTMLAttributes<HTMLWcsSpinnerElement>;
            /**
             * The switch component is a control used to switch between on and off state.
             */
            "wcs-switch": LocalJSX.WcsSwitch & JSXBase.HTMLAttributes<HTMLWcsSwitchElement>;
            /**
             * Tab content component.
             * Use this component to specify the content of a component.
             */
            "wcs-tab": LocalJSX.WcsTab & JSXBase.HTMLAttributes<HTMLWcsTabElement>;
            /**
             * Tabs component to switch between tab content.
             * Use in conjuction with `wcs-tab`.
             * @example ```html
             * <wcs-tabs>
             *    <wcs-tab header="One">The content !</wcs-tab>
             *    <wcs-tab header="Two">More content !</wcs-tab>
             * </wcs-tabs>
             * ```
             * @cssprop --wcs-tabs-width - Width of each tab
             * @cssprop --wcs-tabs-padding-horizontal - Width of each tab
             * @cssprop --wcs-tabs-padding-vertical - Vertical padding
             */
            "wcs-tabs": LocalJSX.WcsTabs & JSXBase.HTMLAttributes<HTMLWcsTabsElement>;
            /**
             * Mainly inspired from Ionic Textarea Component.
             * ## Accessibility guidelines 💡
             * > - If you use wcs-textarea outside a wcs-form-field, you have to manage the label and the error message yourself.
             * > You can use the `aria-label` attribute to provide a label for screen readers but adds no visual label.
             * @cssprop --wcs-textarea-max-height - Max height of the text area component
             * @cssprop --wcs-textarea-padding-left - Padding left of the text area. Take in consideration the transparent border of 2px around the textarea.
             * @cssprop --wcs-textarea-padding-right - Padding right of the text area. Take in consideration the transparent border of 2px around the textarea.
             */
            "wcs-textarea": LocalJSX.WcsTextarea & JSXBase.HTMLAttributes<HTMLWcsTextareaElement>;
            /**
             * Tooltips are used to provide additional information for features available on the website. These can improve the user
             * experience or simply show additional information. Tooltips appear when the user rolls over or clicks on them
             * (for longer content).
             * Note that this component is based on the Tippy.js library : https://atomiks.github.io/tippyjs/
             * ## Accessibility guidelines 💡
             * The problem is that impaired users may not be able to see what is the information provided by the tooltip. To solve
             * this problem, the tooltip should be served with some aria attributes to make it accessible.
             * Aria-features `wcs-tooltip` respect:
             * - dismiss when the user presses the `Escape` key
             * - has a `role=tooltip`
             * But you have to provide the "link" between the element you want to describe and the tooltip. To do this, you have to
             * provide the "visual description" you add on the `wcs-tooltip` to the `aria-label` attribute or the `aria-description` as soon as the attribute will be available 
             * of the element you want to describe .
             * Example:
             * ```html
             * <wcs-tooltip>Trashed items</wcs-tooltip>
             * <wcs-button aria-label="Trashed items">Trash</wcs-button>
             * ```
             */
            "wcs-tooltip": LocalJSX.WcsTooltip & JSXBase.HTMLAttributes<HTMLWcsTooltipElement>;
        }
    }
}
